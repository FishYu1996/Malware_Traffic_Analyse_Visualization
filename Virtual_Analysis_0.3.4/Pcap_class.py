# coding=UTF-8
from util import ByteOrder,ByteTool
import re
'''
没法处理太大的包
'''
INFORM = 0
PATH = 0
COUNT = 1
TEST = 0


def load_pcap(file_name):
    print("Opening file " + file_name)
    f = open(file_name,'rb')
    n = 0
    bytes = []
    s = f.read(1)
    print("Loading......")
    while s:
        bytes.append(ord(s))
        n = n + 1
        if n % 5000 == 0:
            print("%d bytes" % n)
        s = f.read(1)
    print('total bytes: %d'%n)
    f.close()
    if(TEST == 1):
        n = 0
        for byte in bytes:
            n = n + 1
            print('0x%02x,' % (byte), end='')
            if n % 16 == 0:
                print('')
            if n > 160:
                break
        print('')
    return bytes


def build_pcap(file_name, num=1000):
    pcap_file = PcapFile(load_pcap(file_name), num)
    return pcap_file


class PcapFile(object):
    _raw_data = None
    _pcap_head = None
    _packets = []
    _packets_num = None

    def __init__(self, bytes, num):
        self._raw_data = None
        self._pcap_head = None
        self._packets = []
        if PATH == 1:
            print("Pcap Initing")
        self._packets_num = num
        packet_id = 0
        self._raw_data = bytes
        self._change_data = bytes
        if self._pcap_head is None:
            ByteOrder.order = "big"
            self.fill_pcap_head(self._change_data)
            self._change_data = self._change_data[24:]
        while len(self._change_data) > 0:
            packet = Packet(self._change_data[0:1700], packet_id)
            self._packets.append(packet)
            self._change_data = self._change_data[packet.get_packet_head().get_real_len()+16:]
            packet_id += 1
            if packet_id >= self._packets_num:
                print("达到指定包数量")
                break
        print("共有" + str(len(self._packets)) + "个包")


    def fill_pcap_head(self, data):
        data = data[0:24]
        self._pcap_head = PcapHead(data)

    def get_packets(self):
        return self._packets


class PcapHead(object):
    _magic_4B = None
    _major_2B = None
    _minor_2B = None
    _thisZone_4B = None
    _sigFigs_4B = None
    _snapLen_4B = None
    _linkType_4B = None

    def __init__(self, datas):
        if PATH == 1:
            print("  PcapHead Initing")
        self._magic_4B = datas[0:4]
        if PcapHead.signature(self._magic_4B) is False:
            raise Exception("不支持的文件格式")
        self._major_2B = ByteOrder.bytes2int(datas[4:6])
        self._minor_2B = ByteOrder.bytes2int(datas[6:8])
        self._thisZone_4B = ByteOrder.bytes2int(datas[8:12])
        self._sigFigs_4B = ByteOrder.bytes2int(datas[12:16])
        self._snapLen_4B = ByteOrder.bytes2int(datas[16:20])
        self._linkType_4B = ByteOrder.bytes2int(datas[20:24])
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "  order:%s major:%d minor:%d zone:%d sig:%d snap_len:%d type:%d" % (
            ByteOrder.order, self._major_2B, self._minor_2B, self._thisZone_4B, self._sigFigs_4B,self._snapLen_4B,
            self._linkType_4B)

    @staticmethod
    def signature(data):
        """验证签名同时确定排序,虽然此时还未读取到后续大小端"""
        sig = ByteOrder.bytes2int(data)
        if sig == 0xa1b2c3d4:
            ByteOrder.order = "big"
            return True
        elif sig == 0xd4c3b2a1:
            ByteOrder.order = "little"
            return True
        return False


class Packet(object):
    _packet_id = None
    _packetHead_16B = None
    _etherHead_14B = None
    _packet_data = None
    _IPHead = None
    _transportHead = None
    _application = None
    _application_raw = None

    def __init__(self, datas, id):
        ICMP_SKIP_FLAG = 0
        if PATH == 1:
            print("  Packet Initing")
        self._packet_id = id
        if COUNT == 1:
            print("  Packet id " + str(id+1))
        self._packet_data = datas
        self._packetHead_16B = PacketHead(self._packet_data[0:16])
        self._packet_data = self._packet_data[16:self._packetHead_16B.get_real_len()+16]
        self._etherHead_14B = EtherHead(self._packet_data[0:14])
        self._packet_data = self._packet_data[14:]
        self._IPHead = IPHead(self._packet_data)
        self._packet_data = self._packet_data[self.get_ip_head().get_ip_len():]
        app_len = 0
        if self.get_ip_head().get_protocol() == 17:
            self._transportHead = UDPHead(self._packet_data[0:8])
            self._packet_data = self._packet_data[8:]
            app_len = self._transportHead.get_total_len()-8
        elif self.get_ip_head().get_protocol() == 6:
            self._transportHead = TCPHead(self._packet_data)
            self._packet_data = self._packet_data[self._transportHead.get_tcp_len():]
            app_len = self._IPHead.get_total_len() - self._IPHead.get_ip_len() - self._transportHead.get_tcp_len()
        elif self.get_ip_head().get_protocol() == 1:
            #todo
            ICMP_SKIP_FLAG = 1
        #注意ICMP报文未设计
        if (len(self._packet_data) != 0 and ICMP_SKIP_FLAG == 0):
            self._application_raw = self._packet_data
            matcher = ApplicationFinder(self._packet_data[0:app_len], self.get_ip_head().get_protocol(),
                                        self._transportHead.get_ports())
            self._application = matcher.get_application()

    def get_packet_head(self):
        return self._packetHead_16B

    def get_ether_head(self):
        return self._etherHead_14B

    def get_ip_head(self):
        return self._IPHead

    def get_transport_head(self):
        return self._transportHead

    def get_application(self):
        return self._application

    def get_application_raw(self):
        return self._application_raw


class PacketHead(object):
    _secondTime_4B = None
    _millsecondTime_4B = None
    _captureLen_4B = None
    _realLen_4B = None

    def __init__(self,datas):
        if PATH == 1:
            print("    PacketHead Initing")
        self._secondTime_4B =ByteOrder.bytes2int(datas[0:4])
        self._millsecondTime_4B = ByteOrder.bytes2int(datas[4:8])
        self._captureLen_4B = ByteOrder.bytes2int(datas[8:12])
        self._realLen_4B = ByteOrder.bytes2int(datas[12:16])
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "    second:%d millsecond:%d cap_len:%d real_len %d" % (self._secondTime_4B, self._millsecondTime_4B,
                                                                       self._captureLen_4B, self._realLen_4B)

    def get_second_time(self):
        return self._secondTime_4B

    def get_millisecond_time(self):
        return self._millsecondTime_4B

    def get_real_len(self):
        return self._realLen_4B


class EtherHead(object):
    _dst_mac_6B = None
    _src_mac_6B = None
    _type_2B = None

    def __init__(self,datas):
        if PATH == 1:
            print("    Ether Initing")
        self._dst_mac_6B = int.from_bytes(datas[0:6], "big")
        self._src_mac_6B = int.from_bytes(datas[6:12], "big")
        self._type_2B = int.from_bytes(datas[12:14], "big")
        #if hex(self._type_2B) == "0x800":
        #   print("IPv4")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return"    mac_src:%012x mac_dst:%012x type:%04x" % (self._src_mac_6B, self._dst_mac_6B, self._type_2B)

    def get_mac_src(self):
        return self._src_mac_6B

    def get_mac_dst(self):
        return self._dst_mac_6B


class IPHead(object):
    #b是位，B是字节，4b也即是半字节
    _IP_version_4b = None
    _IP_len_4b = None
    _DS_1B = None
    _total_len_2B = None
    _identification_2B = None
    _flag_3b = None
    _deviation_13b = None
    _TTL_1B = None
    _protocol_1B = None
    _check_sum_2B = None
    _srcIp_4B = None
    _dstIp_4B = None

    def __init__(self,datas):
        if PATH == 1:
            print("    IPHead Initing")
        self._IP_version_4b = ByteTool.disassembleBytes(datas[0:1], 0, 3)
        self._IP_len_4b = ByteTool.disassembleBytes(datas[0:1], 4, 7) * 4
        self._DS_1B = int.from_bytes(datas[1:2], "big")
        self._total_len_2B = int.from_bytes(datas[2:4], "big")
        self._identification_2B = int.from_bytes(datas[4:6], "big")
        self._flag_3b = ByteTool.disassembleBytes(datas[6:8], 0, 2)
        self._deviation_13b = ByteTool.disassembleBytes(datas[6:8], 3, 15)
        self._TTL_1B = int.from_bytes(datas[8:9], "big")
        self._protocol_1B = int.from_bytes(datas[9:10], "big")
        self._check_sum_2B = int.from_bytes(datas[10:12], "big")
        self._srcIp_4B = int.from_bytes(datas[12:16], "big")
        self._dstIp_4B = int.from_bytes(datas[16:20], "big")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "    version:%d len:%d DS:%d total_len:%d identi:%d flag:%01x deviation:%d TTL:%d protocol:%d " \
               "check_sum:%04x srcIP:%08x dstIP:%08x" % (self._IP_version_4b, self._IP_len_4b, self._DS_1B, self._total_len_2B,
                                          self._identification_2B, self._flag_3b, self._deviation_13b, self._TTL_1B,
                                          self._protocol_1B, self._check_sum_2B, self._srcIp_4B, self._dstIp_4B)

    def get_ip_version(self):
        return self._IP_version_4b

    def get_ip_len(self):
        return self._IP_len_4b

    def get_total_len(self):
        return self._total_len_2B

    def get_ttl(self):
        return self._TTL_1B

    def get_protocol(self):
        return self._protocol_1B

    def get_srcIP(self):
        return self._srcIp_4B

    def get_dstIP(self):
        return self._dstIp_4B


class UDPHead(object):
    _src_port_2B = None
    _dst_port_2B = None
    _UDP_len_2B = None
    _check_sum_2B = None
    _identify = None

    def __init__(self,datas):
        if PATH == 1:
            print("    UDP Initing")
        self._identify = "UDP"
        self._src_port_2B = int.from_bytes(datas[0:2], "big")
        self._dst_port_2B = int.from_bytes(datas[2:4], "big")
        self._UDP_len_2B = int.from_bytes(datas[4:6], "big")
        self._check_sum_2B = int.from_bytes(datas[6:8], "big")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return"    srcPort:%d dstPort:%d UDP_Len:%d checkSum:%04x" % (self._src_port_2B, self._dst_port_2B,
                                                                   self._UDP_len_2B, self._check_sum_2B)

    def get_identify(self):
        return self._identify

    @staticmethod
    def get_udp_len():
        return 8

    def get_total_len(self):
        return self._UDP_len_2B

    def get_ports(self):
        ports = [self._src_port_2B, self._dst_port_2B]
        return ports


class TCPHead(object):
    _src_port_2B = None
    _dst_port_2B= None
    _seq_number_4B = None
    _ack_number_4B = None
    _TCP_len_4b = None
    _flag_1B = None
    _window_2B = None
    _check_sum_2B = None
    _urgent_flag_2B = None
    _option = None
    _option_len = None
    _identify = None

    def __init__(self,datas):
        if PATH == 1:
            print("    TCP Initing")
        self._identify = "TCP"
        self._src_port_2B = int.from_bytes(datas[0:2], "big")
        self._dst_port_2B = int.from_bytes(datas[2:4], "big")
        self._seq_number_4B = int.from_bytes(datas[4:8], "big")
        self._ack_number_4B = int.from_bytes(datas[8:12], "big")
        self._TCP_len_4b = ByteTool.disassembleBytes(datas[12:13], 0, 3) * 4
        self._flag_1B = int.from_bytes(datas[13:14], "big")
        self._window_2B = int.from_bytes(datas[14:16], "big")
        self._check_sum_2B = int.from_bytes(datas[16:18], "big")
        self._urgent_flag_2B = int.from_bytes(datas[18:20], "big")
        self._option_len = self._TCP_len_4b - 20
        self._option = int.from_bytes(datas[20:20+self._option_len], "big")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return("    src_port:%d dst_port:%d seq_num:%d ack_num:%d Tcp_len:%d flag:%02x win:%d check_sum:%d "
               "urgent_flag:%d option_len:%d option:%x") % (self._src_port_2B, self._dst_port_2B, self._seq_number_4B,
                                                            self._ack_number_4B, self._TCP_len_4b, self._flag_1B,
                                                            self._window_2B, self._check_sum_2B, self._urgent_flag_2B,
                                                            self._option_len, self._option)

    def get_ports(self):
        ports = [self._src_port_2B, self._dst_port_2B]
        return ports

    def get_seq(self):
        return self._seq_number_4B

    def get_ack(self):
        return self._ack_number_4B

    def get_tcp_len(self):
        return self._TCP_len_4b

    def get_flag(self):
        return self._flag_1B

    def get_option_len(self):
        return self._option_len

    def get_option_content(self):
        return self._option

    def get_identify(self):
        return self._identify


class ApplicationFinder(object):
    _result_application = None
    _application_entity = None
    _application_detail = None
    _application_content = None
    _app_datas = None
    _transport_protocol = None
    _transport_ports = None
    complete_flag = False

    def __init__(self, datas, transport_protocol, transport_ports=None):
        self._app_datas = datas
        self._transport_protocol = transport_protocol
        self._transport_ports = transport_ports
        self._application_entity = self.matcher()

    def __str__(self):
        return "    Application:%s" % (self._result_application)

    def matcher(self):
        flag = False
        application_entity = None
        if self._transport_protocol == 6:
            #http可以用80端口先一步过滤，不过滤也可以
            if self.find_port(443):
                application_entity = TLSData(self._app_datas)
                return application_entity
            flag, application_entity = self.HTTP_matcher()
            if flag is True:
                return application_entity
            if PATH == 1:
                print("    TCP application")
        elif self._transport_protocol == 17:
            if self.find_port(53):
                application_entity = DnsData(self._app_datas)
                self._result_application = "DNS"
                return application_entity
            print("    UDP application")

    def HTTP_matcher(self):
        data_string = ""
        flag = False
        for app_data in self._app_datas:
            data_string += chr(app_data)
        result_request = re.match('[a-zA-Z]{3,7} .* HTTP/1.[0,1]', data_string)
        result_response = re.match('HTTP/1.[0,1] [0-9]{0,3} *', data_string)
        if (result_request):
            self._result_application = "HTTP"
            self._application_detail = "Request"
            self._application_content = data_string
            flag = True
        elif(result_response):
            self._result_application = "HTTP"
            self._application_detail = "Response"
            self._application_content = data_string
            flag = True
        if flag is True:
            self._application_entity = HttpData(self._application_detail, self._application_content)
        return flag, self._application_entity

    def get_application(self):
        return self._application_entity

    def find_port(self, target_port):
        if self._transport_ports is not None:
            for port in self._transport_ports:
                if port == target_port:
                    return True
            return False
        else:
            print("No port information")
            return False


class HttpData(object):
    _type = None
    _method = None
    _uri = None
    _host = None
    _data = None
    _content_type = None
    _content_length = None
    _identify = None

    def __init__(self, type, content):
        if PATH == 1:
            print("    HTTP Initing")
        self._type = type
        self._data = content
        if self._type == "Request":
            i = 0
            j = i
            i = self.find_method_boundry(i)
            self._method = self._data[j:i]
            j = i
            i = self.find_method_boundry(i)
            self._uri = self._data[j:i]
            temp_index = self._data.find("Host")
            if temp_index != -1:
                self._host = self.find_information(temp_index, 6)
        elif self._type == "Response":
            str_list = ["Content-Type", "Content-Length"]
            i = 0
            for meta in str_list:
                temp_index = self._data.find(meta)
                if temp_index != -1:
                    if i == 0:
                        self._content_type = self.find_information(temp_index, 14)
                    elif i == 1:
                        self._content_length = self.find_information(temp_index, 16)
                        self._content_length = int(self._content_length)
                i += 1
        self._identify = "HTTP"
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "     http_type:%s http_data:%s" % (self._type, self._data)

    def find_method_boundry(self, i):
        for meta in self._data[i:]:
            if ord(meta) == 32:
                i += 1
                break
            i += 1
        return i

    def find_information(self, start_index, deviation):
        temp_str = ""
        for char in self._data[start_index + deviation:]:
            if char == "\r":
                break
            else:
                temp_str += char
        return temp_str

    def get_type(self):
        return self._type

    def get_method(self):
        return self._method

    def get_uri(self):
        return self._uri

    def get_host(self):
        return self._host

    def get_content_type(self):
        return  self._content_type

    def get_content_length(self):
        return self._content_length

    def get_identify(self):
        return self._identify


class DnsData(object):
    _raw_data = None
    _transaction_id_2B = None
    _flag_2B = None
    _question_num_2B = None
    _answer_num_2B = None
    _authority_num_2B = None
    _additional_num_2B = None
    _querys = []
    _answers = []
    _others = None
    _data = None
    _identify = None
    _direction = None

    def __init__(self, content):
        if PATH == 1:
            print("    DNS Initing")
        self._identify = "DNS"
        self._querys = []
        self._answers = []
        self._raw_data = content
        self._data = content
        self.fill_dns_head()
        if INFORM == 1:
            print(self.__str__())
        self._data = self._data[12:]
        for num in range(0, self._question_num_2B):
            query = self.Query(self._data)
            self._querys.append(query)
            self._data = self._data[query.get_size():]
        for num in range(0, self._answer_num_2B):
            answer = self.Answer(self._data, self)
            self._answers.append(answer)
            self._data = self._data[answer.get_size():]
        if self._flag_2B & 32768 != 0:
            self._direction = "Response"
        else:
            self._direction = "Request"

        self._others = self._data

    def fill_dns_head(self):
        self._transaction_id_2B = int.from_bytes(self._data[0:2], "big")
        self._flag_2B = int.from_bytes(self._data[2:4], "big")
        self._question_num_2B = int.from_bytes(self._data[4:6], "big")
        self._answer_num_2B = int.from_bytes(self._data[6:8], "big")
        self._authority_num_2B = int.from_bytes(self._data[8:10], "big")
        self._additional_num_2B = int.from_bytes(self._data[10:12], "big")

    def get_raw_data(self):
        return self._raw_data

    def get_transaction(self):
        return self._transaction_id_2B

    def get_direction(self):
        return  self._direction

    def get_querys(self):
        return self._querys

    def get_answers(self):
        return self._answers

    def __str__(self):
        return("    transaction_id:%d flag:%x question_num:%d answer_num:%d " % (self._transaction_id_2B,
                                                                                 self._flag_2B,
                                                                                 self._question_num_2B,
                                                                                 self._answer_num_2B))

    def get_identify(self):
        return self._identify

    class Query(object):
        _domain = None
        _type = None
        _class = None
        _size = None
        _query_content = None

        def __init__(self, datas):
            if PATH == 1:
                print("      DNS_Query_Initing")
            self._query_content = datas
            self._domain, self._size = self.domain_connect(self._query_content)
            self._type = int.from_bytes(self._query_content[self._size:self._size+2], "big")
            self._size += 2
            self._class = int.from_bytes(self._query_content[self._size:self._size+2], "big")
            self._size += 2
            if INFORM == 1:
                print(self.__str__())

        def domain_connect(self, datas):
            domain = ""
            content = datas
            size = 0
            while content[0] != 0:
                chr_num = int.from_bytes(content[0:1], "big")
                size += 1
                for data in content[1:1+chr_num]:
                    domain += chr(data)
                domain += "."
                content = content[1+chr_num:]
                size += chr_num
            domain = domain[0:len(domain)-1]
            size += 1
            return domain, size

        def __str__(self):
            return "      domain:%s type:%x class:%x size:%d" % (self._domain, self._type, self._class, self._size)

        def get_type(self):
            return self._type

        def get_size(self):
            return self._size

        def get_domain(self):
            return self._domain

    class Answer(object):
        _domain = None
        _type = None
        _class = None
        _TTL = None
        _data_length = None
        _datas = None
        _answer_content = None
        _size = None
        _raw = None
        _out_obj =None

        def __init__(self, datas, obj):
            self._size = 0
            if PATH == 1:
                print("      DNS_Answer_Initing")
            self._answer_content = datas
            self._out_obj = obj
            domain_type_flag = self.domain_type(self._answer_content[0:1])
            if domain_type_flag == 1:
                deviation = int.from_bytes(self._answer_content[1:2], "big")
                self._raw = obj.get_raw_data()
                self._domain, self._size = self.domain_connect(self._raw[deviation:])
                self._size = 2
                self._answer_content = self._answer_content[2:]
            self._type = int.from_bytes(self._answer_content[0:2], "big")
            self._class = int.from_bytes(self._answer_content[2:4], "big")
            self._TTL = int.from_bytes(self._answer_content[4:8], "big")
            self._data_length = int.from_bytes(self._answer_content[8:10], "big")
            self._datas = int.from_bytes(self._answer_content[10:10+self._data_length], "big")
            self._size += 10
            self._size += self._data_length
            if INFORM == 1:
                print(self.__str__())

        def domain_connect(self, content_out):
            domain = ""
            content = content_out
            size = 0
            while content[0] != 0:
                chr_num = int.from_bytes(content[0:1], "big")
                size += 1
                if chr_num != 192:
                    for data in content[1:1+chr_num]:
                        domain += chr(data)
                    domain += "."
                    content = content[1+chr_num:]
                    size += chr_num
                else:
                    content = self.get_raw()[content[1]:]
            domain = domain[0:len(domain) - 1]
            size += 1
            return domain, size

        def domain_type(self, first_byte):
            if(int.from_bytes(first_byte, "big") == 192):
                return 1
            else:
                return 0

        def get_size(self):
            return self._size

        def get_raw(self):
            return  self._raw

        def get_type(self):
            return self._type

        def get_domain(self):
            return self._domain

        def get_datas(self):
            return self._datas

        def __str__(self):
            return("      domain:%s type:%d class:%d TTL:%d data_length:%d datas:%x size:%d " % (self._domain,
                                                                                                 self._type,
                                                                                              self._class, self._TTL,
                                                                                              self._data_length,
                                                                                              self._datas, self._size))


class TLSData(object):
    _data = None
    _identify = None

    def __init__(self, content):
        if PATH == 1:
            print("      TLS Initing")
        self._data = content
        self._identify = "TLS"
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "      TLS"

    def get_identify(self):
        return self._identify



