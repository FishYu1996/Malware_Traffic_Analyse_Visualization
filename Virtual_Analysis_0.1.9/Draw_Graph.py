# coding=UTF-8
import networkx as nx
import matplotlib.pyplot as plt
import math
import re as re
from matplotlib.patches import FancyArrowPatch, Circle
import numpy as np
import matplotlib.patches as mpatches
import Analyser
from netwulf import visualize


G = nx.Graph()#总图
H=  nx.Graph()#连通子图
J=  nx.Graph()#无向图
L=  nx.MultiDiGraph()#重图
weight=[]
abnormal_IP_list=[]

def create_wholeGraph():
    global G, sql
    sql = "select * from Link"
    results = Analyser.get_data(sql)
    i = 0
    for r in results:
        G.add_edge(r[1], r[2], weight=r[3])
        i = i + 1

def list_subGraph():
    global G, H,J
    sublist = list(nx.connected_components(G))
    nodes = []
    sub_number = 0
    while sub_number < sublist.__len__():
        H = G.subgraph(list(sublist[sub_number]))
        J = H.copy()
        IPs = list(degree(0))
        sub_number += 1
        nodes.append(IPs[0])
    return nodes


def draw_all():
    global G, sql,J
    sql = "select * from link"
    results = Analyser.get_data(sql)
    i = 0
    weight = []
    for r in results:
        G.add_edge(r[1], r[2], weight=r[3])
        i = i + 1
    edgelists = [(u, v,d['weight']) for (u, v, d) in G.edges(data=True)]
    for edgelist in edgelists:
        row_weight=edgelist[2]
        weight.append(math.sqrt(row_weight / 10) + 1)
    color = decide_node_color(G)
    pos = nx.spring_layout(G, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(G, pos, node_size=200,node_color=color)
    nx.draw_networkx_edges(G,pos,edgelists,width=weight)
    nx.draw_networkx_labels(G, pos, font_size=5, font_family='sans-serif')
    nodes = list(G.nodes)
    J=G.copy()
    #visualize(G)
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    return nodes


def draw_SingleIP(IP):
    global sql,J
    J.clear()
    sql="select * from Link where IP1='"+ IP +"'or IP2='"+IP+"'"
    results = Analyser.get_data(sql)
    i = 0
    weight = []
    for r in results:
        J.add_edge(r[1], r[2], weight=r[3])
        i = i + 1
    edgelists = [(u, v, d['weight']) for (u, v, d) in J.edges(data=True)]
    for edgelist in edgelists:
        row_weight = edgelist[2]
        weight.append(math.sqrt(row_weight / 10) + 1)
    color = decide_node_color(J)
    pos = nx.spring_layout(J, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(J, pos, node_size=200,node_color=color)
    nx.draw_networkx_edges(J, pos, edgelists,width=weight)
    nx.draw_networkx_labels(J, pos, font_size=5, font_family='sans-serif')
    nodes=list(J.nodes)
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    return nodes

def degree(mode):
    if mode ==0:
        degree_saves=nx.degree(J)
        order_degree_rank=sorted(degree_saves,key=lambda x:x[1],reverse=True)
        return order_degree_rank
    elif mode==1:
        degree_saves = nx.degree(H)
        order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
        return order_degree_rank

def betweeness(mode):
    if mode==0 :
        betweeness_saves = nx.betweenness_centrality(J)
        order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
        return order_betweeness_rank
    elif mode==1:
        betweeness_saves = nx.betweenness_centrality(H)
        order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
        return order_betweeness_rank

def degree_centrality(mode):
    if(mode==0):
        degree_centrality_saves = nx.degree_centrality(J)
        order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
        return order_degree_centrality_rank
    elif (mode == 1):
        degree_centrality_saves = nx.degree_centrality(H)
        order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
        return order_degree_centrality_rank

def change_subgraph(id):
    sublist = list(nx.connected_components(G))
    weight = []
    global H,J
    H = G.subgraph(list(sublist[id]))
    edgelists = [(u, v, d['weight']) for (u, v, d) in H.edges(data=True)]
    for edgelist in edgelists:
        row_weight = edgelist[2]
        weight.append(math.sqrt(row_weight / 10) + 1)
    color=decide_node_color(H)
    pos = nx.spring_layout(H, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(H, pos, node_size=200,node_color=color)
    nx.draw_networkx_edges(H, pos, width=weight)
    nx.draw_networkx_labels(H, pos, font_size=5, font_family='sans-serif')
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    J=H.copy()

def transfer_nodes():
    return list(J.nodes)

def transfer_subnodes():
    return list(H.nodes)

def draw_pie(propers):
    plt.figure(figsize=(6, 5))
    protocols = [u'DNS', u'HTTP', u'HTTPS', u'TCP', u'UDP']
    colors = ['red', 'yellow', 'blue', 'green','pink']
    act_protocols=[]
    act_propers=[]
    act_colors=[]
    explode=[]
    counter=0
    for proper in propers:
        proper_float=float(proper)
        if proper_float!=0:
            act_protocols.append(protocols[counter])
            act_propers.append(proper_float)
            act_colors.append(colors[counter])
            explode.append(0.05)
        counter+=1
    act_explode = tuple(explode)

    patches, l_text, p_text = plt.pie(act_propers, explode=act_explode, labels= act_protocols, colors=act_colors,
                                       labeldistance=1.1, autopct='%2.1f%%', shadow=False,
                                       startangle=90, pctdistance=0.8)

    # labeldistance，文本的位置离远点有多远，1.1指1.1倍半径的位置
    # autopct，圆里面的文本格式，%3.1f%%表示小数有三位，整数有一位的浮点数
    # shadow，饼是否有阴影
    # startangle，起始角度，0，表示从0开始逆时针转，为第一块。一般选择从90度开始比较好看
    # pctdistance，百分比的text离圆心的距离
    # patches, l_texts, p_texts，为了得到饼图的返回值，p_texts饼图内部文本的，l_texts饼图外label的文本

    # 改变文本的大小
    # 方法是把每一个text遍历。调用set_size方法设置它的属性
    for t in l_text:
        t.set_size = 30
    for t in p_text:
        t.set_size = 20
        # 设置x，y轴刻度一致，这样饼图才能是圆的
    plt.axis('equal')
    plt.legend(loc='upper left', bbox_to_anchor=(-0.1, 1.1))
    # loc: 表示legend的位置，包括'upper right','upper left','lower right','lower left'等
    # bbox_to_anchor: 表示legend距离图形之间的距离，当出现图形与legend重叠时，可使用bbox_to_anchor进行调整legend的位置
    # 由两个参数决定，第一个参数为legend距离左边的距离，第二个参数为距离下面的距离
    plt.grid()
    plt.savefig("pie.png")
    plt.clf()
    plt.close('all')

def draw_Line(IP1,IP2):
    global L,sql
    i=0
    while i<2:
        if i==0:
            srcIP=IP1
            dstIP=IP2
        elif i==1:
            srcIP = IP2
            dstIP = IP1
        protocols = Analyser.Link_Protocol_Analyse(srcIP, dstIP, 1)
        protocol_proper = []
        protocol_label=1
        for protocol in protocols:
            string = str(protocol)
            inform = re.split(r"/|", string)
            int_protocol_proper=int(inform[0])
            if int_protocol_proper!=0:
                L.add_edge(srcIP,dstIP, sty=protocol_label, width=(math.sqrt(int_protocol_proper))/3)
            protocol_label+=1
        i+=1
    pos = nx.spring_layout(L)
    ax = plt.gca()
    draw_MultipleLine(L, pos, ax)
    ax.autoscale()

    color_example = []
    red_patch = mpatches.Patch(color='red', label='DNS')
    color_example.append(red_patch)
    blue_patch = mpatches.Patch(color='blue', label='HTTP')
    color_example.append(blue_patch)
    black_patch = mpatches.Patch(color='black', label='HTTPS')
    color_example.append(black_patch)
    yellow_patch = mpatches.Patch(color='yellow', label='TCP')
    color_example.append(yellow_patch)
    green_patch = mpatches.Patch(color='green', label='UDP')
    color_example.append(green_patch)
    plt.legend(handles=color_example)

    nx.draw_networkx_labels(L, pos, font_size=5, font_family='sans-serif')
    L.clear()
    plt.axis('equal')
    plt.axis('off')
    plt.savefig("Line.png")
    plt.clf()
    plt.close('all')

def draw_MultipleLine(L,pos,ax,sg=None):
    for n in L:
        c=Circle(pos[n],radius=0.05,alpha=0.7)
        ax.add_patch(c)
        L.node[n]['patch']=c
        x,y=pos[n]
    seen={}
    for (u,v,d) in L.edges(data=True):
        n1=L.node[u]['patch']
        n2=L.node[v]['patch']
        rad=0.1
        if (u,v) in seen:
            rad=seen.get((u,v))
            rad=(rad+np.sign(rad)*0.1)*-1
        alpha=0.5
        style=d['sty']
        if style==1:
            color='r'
        elif style==2:
            color='b'
        elif style==3:
            color='k'
        elif style==4:
            color='y'
        elif style==5:
            color='g'

        width=d['width']
        line=width
        e = FancyArrowPatch(n1.center,n2.center,patchA=n1,patchB=n2,
                            arrowstyle='-|>',
                            connectionstyle='arc3,rad=%s'%rad,
                            mutation_scale=10.0,
                            lw=2,
                            alpha=alpha,
                            color=color)
        e.set_linewidth(line)
        e.set_label(line)
        seen[(u,v)]=rad
        ax.add_patch(e)
    return e


def decide_node_color(H):
    flag = 0
    abnomal_IP_list = Analyser.read_abnormal_IP_list()
    color = []
    for node in H.nodes:
        for abnormal_IP in abnomal_IP_list:
            IP = abnormal_IP[0]
            if node == IP:
                color.append('r')
                flag = 1
                break
        if flag != 1:
            color.append('b')
        else:
            flag = 0
    return color

