# coding=UTF-8
import MySQLdb
import operator
import LSTM_dga
import re as re
abnormal_dict={}

def get_data(sql):
    conn = MySQLdb.connect("localhost", "root", "root", "Test")
    cursor = conn.cursor()
    # 查询test表中id为11的记录，并将记录数目返回给count
    cursor.execute(sql)
    # 重置游标位置，0,为偏移量，mode＝absolute | relative,默认为relative,
    if(cursor.rowcount!=0):
        cursor.scroll(0, mode='absolute')
        results = cursor.fetchall()
    else:
        results=()
    conn.close()
    return results


def insert_data(sql):
    conn = MySQLdb.connect("localhost", "root", "root", "Test")
    cursor = conn.cursor()
    cursor.execute(sql)
    cursor.close()
    conn.commit()
    conn.close()


def clear_table(table):
    conn = MySQLdb.connect("localhost", "root", "root", "Test")
    cursor = conn.cursor()
    sql="truncate "+table
    cursor.execute(sql)


def find_last_id(table):
    sql = "select id from `"+table+"` order by id desc LIMIT 1"
    results = get_data(sql)
    if not results:
        id = 1
    else:
        for result in results:
            id = result[0] + 1
            break
    return id

def Node_Length_Analyse(nodes):
    max=200
    min=0
    prop=0
    all=0
    sum=0
    propdic={}
    for node in nodes:
        sql="SELECT length FROM `data` where srcIp='"+node+"'or dscIp='"+node+"'"
        results=get_data(sql)
        for result in results:
            all+=1
            if result[0]>min and result[0]<max:
                sum+=1
        prop=float(sum)/all
        propdic[node]=prop
        sum=0
        all=0
        ordered_propdic = sorted(propdic.items(), key=lambda x: x[1], reverse=True)
    return ordered_propdic


def Node_Links_Analyse(nodes):
    Links={}
    for node in nodes:
        sql="SELECT sum(count) FROM `link` where IP1='"+node+"'OR IP2='"+node+"'"
        results=get_data(sql)
        for result in results:
            Links[node]=result[0]
        ordered_Links = sorted(Links.items(), key=lambda x: x[1], reverse=True)
    return ordered_Links

def All_Link_Analyse():
    sql = "SELECT * FROM `link`"
    results = get_data(sql)
    Links=[]
    for result in results:
        IP1=result[1]
        IP2=result[2]
        Link=(IP1,IP2)
        Links.append(Link)
    return Links
def Link_Connections():
    sql = "SELECT * FROM `link`"
    results = get_data(sql)
    Links = {}
    for result in results:
        IP1 = result[1]
        IP2 = result[2]
        connection=result[3]
        str=IP1+"->"+IP2
        Links[str]=connection
        # sql = "SELECT protocol,appProto FROM `data` where (srcIp='" + IP1 + "'and dscIp='"+IP2+"')or(srcIp='"+IP2+"'and dscIp='"+IP1+"')"
        ordered_Links = sorted(Links.items(), key=lambda x: x[1], reverse=True)
    return ordered_Links
def Link_Connection(IP1,IP2):
    sql = "SELECT count FROM `link` where (IP1='" + IP1 + "'and IP2='"+IP2+"')or(IP1='"+IP2+"'and IP2='"+IP1+"')"
    results = get_data(sql)
    count=0
    for result in results:
        count=result[0]
        break
    return count

def Link_Length_Analyse(IP1,IP2):
    i=0
    String=[]
    sql="SELECT length FROM `data`  where (srcIp='" + IP1 + "'and dscIp='"+IP2+"')or(srcIp='"+IP2+"'and dscIp='"+IP1+"')"
    results=get_data(sql)
    max=200
    min=0
    while i<2:
        count = 0
        sum = 0
        for result in results:
            if result[0]>min and result[0]<max:
                count+=1
            sum+=1
        prop=round(float(count)/sum,5)
        String.append(str(count)+"/"+str(prop))
        max = 1500
        min = 1000
        i+=1
    return String


def Link_Protocol_Analyse(IP1,IP2,mode=0):
    String = []
    DNS = 0
    HTTP = 0
    HTTPS = 0
    TCP = 0
    UDP = 0
    sum = 0
    if mode == 0:
        sql = "SELECT protocol,appProto FROM `data`  where (srcIp='" + IP1 + "'and dscIp='" + IP2 + "')or(srcIp='" + IP2 + "'and dscIp='" + IP1 + "')"
    if mode == 1:
        sql = "SELECT protocol,appProto FROM `data`  where (srcIp='" + IP1 + "'and dscIp='" + IP2 + "')"
    results = get_data(sql)
    for result in results:
        sum+=1
        if operator.eq(result[1],"null")==True:
            if result[0]==17:
                UDP+=1
            elif result[0]==6:
                TCP+=1
        else:
            if operator.eq(result[1],"HTTP")==True:
                HTTP+=1
                continue
            if operator.eq(result[1],"HTTPS") == True:
                HTTPS += 1
                continue
            if operator.eq(result[1],"DNS") == True:
                DNS += 1
                continue
    if sum == 0:
        sum = 1
    prop = round(float(DNS) / sum, 5)
    String.append(str(DNS) + "/" + str(prop))
    prop = round(float(HTTP) / sum, 5)
    String.append(str(HTTP) + "/" + str(prop))
    prop = round(float(HTTPS) / sum, 5)
    String.append(str(HTTPS) + "/" + str(prop))
    prop = round(float(TCP) / sum, 5)
    String.append(str(TCP) + "/" + str(prop))
    prop = round(float(UDP) / sum, 5)
    String.append(str(UDP) + "/" + str(prop))
    return String

def Wrong_Matched_Port():
    IPs={}
    sql="select srcIp,dscIp from `data` where srcPort=80 AND appProto='null'"
    count=0
    results=get_data(sql)
    for result in results:
        str=result[0]+"->"+result[1]+"     HTTP-80"
        if str in IPs:
            count=IPs[str]
            IPs[str]=count+1
        else:
            count=1
            IPs[str]=count
    IPs = sorted(IPs.items(), key=lambda x: x[1], reverse=True)
    return IPs

def DNS_HTTP_Mode():
    DH_Mode=[]
    sql = "select * from `data` where appProto='DNS' and  appInform4 is not null "
    results = get_data(sql)
    if  results:
        for result in results:
            DNS_Server=result[3]
            Queryer=result[4]
            Answer=result[13]
            DH_Single=[]
            DH_Single.append(Queryer)
            DH_Single.append(result[3])
            DH_Single.append(Answer)
            sql = "select * from `data` where appProto='HTTP' and  srcIp='"+Queryer+"'and dscIp='"+Answer+"'"
            results = get_data(sql)
            if results:
                sql = "select count from `link` where (IP1='" + Queryer + "'and IP2='" + Answer + \
                      "')or(IP1='"+Answer+"'and IP2='"+Queryer+"')"
                results = get_data(sql)
                DH_Single.append(results[0][0])
                DH_Mode.append(DH_Single)
            else:
                print("null")
    else:
        print("null")
    IP_Links={}
    for DH_Single in DH_Mode:
        str=DH_Single[0]+"->"+DH_Single[1]+"->"+DH_Single[2]
        IP_Links[str] = DH_Single[3]
    IP_Links = sorted(IP_Links.items(), key=lambda x: x[1], reverse=True)
    return IP_Links

def predict_dga():
    #根据HTTP的HOST判断请求的目标地址是否用了dga
    global abnormal_dict
    sql="select dscIp,appInform2 from `data` where appProto='HTTP' and appInform2 !=''"
    results = get_data(sql)
    test_dict={}
    inputlists=[]
    for result in results:
        split_result=result[1].split('.')
        if split_result[0] in test_dict:
            print("in")
        else:
            test_dict[split_result[0]]=result[0]
            inputlists.append(split_result[0])
    #####
    abnormal_domains=LSTM_dga.predict_dga(inputlists)
    id=find_last_id("abnormal_list")
    for abnormal_domain in abnormal_domains:
        abnormal_ip=test_dict[abnormal_domain]
        flag="YES"
        sql = "Insert into abnormal_list(id,IP,has_dga) values (" + str(id) + ",'" + abnormal_ip + "','" + flag + "')"
        #print(sql)
        insert_data(sql)
        if abnormal_ip in abnormal_dict:
            abnormal_dict[abnormal_ip]+=1
        else:
            abnormal_dict[abnormal_ip]=1
        id+=1


def Necurs_flaw_Amy():
    C2Servers=[]
    InfectedIPs=[]
    sql = "select srcIp,dscIp,appInform3 from `data` where appProto='HTTP' and appInform ='Response'"
    results = get_data(sql)
    for result in results:
        stateflag = 0
        if(int(result[2])>160 and int(result[2])<180):
            stateflag+=10
            tempServer = result[0]
            tempInfect = result[1]
            sql = "select srcIp,dscIp,appInform3 from `data` where appProto='HTTP' and appInform ='Response'and dscIP='"+ tempInfect +"'"
            results_2 = get_data(sql)
            for result_2 in results_2:
                if (stateflag==10 and int(result_2[2]) > 300 and int(result_2[2]) < 330):
                    stateflag += 10
                elif (stateflag==20 and int(result_2[2]) > 120000 and int(result_2[2]) < 230000):
                    stateflag+=5
                elif (stateflag >= 20 and int(result_2[2]) > 650000 and int(result_2[2]) < 900000):
                    stateflag+=10
                if stateflag>=30:
                    C2Servers.append(tempServer)
                    InfectedIPs.append(tempInfect)
    C2Servers=list(set(C2Servers))
    InfectedIPs=list(set(InfectedIPs))
    for  C2Server in C2Servers:
        if  C2Server in abnormal_dict:
            abnormal_dict[C2Server]+=1
            sql="update abnormal_list set Necurs_FlawedAmy='C&C Server' where IP='"+C2Server+"'"
            insert_data(sql)
        else:
            abnormal_dict[ C2Server]=1
            id = find_last_id("abnormal_list")
            sql = "Insert into abnormal_list(id,IP,Necurs_FlawedAmy) values (" + str(id) + ",'" +  C2Server + "','C&C Server')"
            insert_data(sql)
    for  InfectedIP in InfectedIPs:
        if  InfectedIP in abnormal_dict:
            abnormal_dict[InfectedIP]+=1
            sql="update abnormal_list set Necurs_FlawedAmy='Infected' where IP='"+C2Server+"'"
            insert_data(sql)
        else:
            abnormal_dict[InfectedIP]=1
            id = find_last_id("abnormal_list")
            sql = "Insert into abnormal_list(id,IP,Necurs_FlawedAmy) values (" + str(id) + ",'" +  InfectedIP + "','Infected')"
            insert_data(sql)

def abnormal_modes_analyse():
    global abnormal_dict
    abnormal_dict = {}
    clear_table("abnormal_list")
    abnormal_IPs_Ranks=[]
    predict_dga()
    Necurs_flaw_Amy()
    for key in abnormal_dict:
        tuple=(key,abnormal_dict[key])
        abnormal_IPs_Ranks.append(tuple)
    order_abnormal_IPs_Ranks = sorted(abnormal_IPs_Ranks, key=lambda x: x[1], reverse=True)
    return order_abnormal_IPs_Ranks


def read_abnormal_IP_list():
    sql = "select IP from `abnormal_list`"
    results = get_data(sql)
    return(results)