# coding=UTF-8
from util import ByteOrder,ByteTool
import re
'''
没法处理太大的包
'''
INFORM = 0
TEST = 0


def load_pcap(file_name):
    f = open(file_name,'rb')
    n = 0
    bytes = []
    s = f.read(1)
    while s:
        bytes.append(ord(s))
        n = n + 1
        s = f.read(1)
    print("Loading......")
    print('total bytes: %d'%n)
    f.close()
    if(TEST == 1):
        n = 0
        for byte in bytes:
            n = n + 1
            print('0x%02x,' % (byte), end='')
            if n % 16 == 0:
                print('')
            if n > 160:
                break
        print('')
    return bytes


class PcapFile(object):
    _raw_data = None
    _pcap_head = None
    _packets = []

    def __init__(self, bytes):
        print("Pcap Initing")
        packet_id = 0
        self._raw_data = bytes
        self._change_data = bytes
        if self._pcap_head is None:
            self.fill_pcap_head(self._change_data)
            self._change_data = self._change_data[24:]
        while len(self._change_data) > 0:
            packet = Packet(self._change_data,packet_id)
            self._packets.append(packet)
            self._change_data =self._change_data[packet.get_packet_head().get_real_len()+16:]
            packet_id += 1
        print(len(self._packets))

    def fill_pcap_head(self, data):
        data = data[0:24]
        self._pcap_head = PcapHead(data)


class PcapHead(object):
    _magic_4B = None
    _major_2B = None
    _minor_2B = None
    _thisZone_4B = None
    _sigFigs_4B = None
    _snapLen_4B = None
    _linkType_4B = None

    def __init__(self, datas):
        print("  PcapHead Initing")
        self._magic_4B = datas[0:4]
        if PcapHead.signature(self._magic_4B) is False:
            raise Exception("不支持的文件格式")
        self._major_2B = ByteOrder.bytes2int(datas[4:6])
        self._minor_2B = ByteOrder.bytes2int(datas[6:8])
        self._thisZone_4B = ByteOrder.bytes2int(datas[8:12])
        self._sigFigs_4B = ByteOrder.bytes2int(datas[12:16])
        self._snapLen_4B = ByteOrder.bytes2int(datas[16:20])
        self._linkType_4B = ByteOrder.bytes2int(datas[20:24])
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "  order:%s major:%d minor:%d zone:%d sig:%d snap_len:%d type:%d" % (
            ByteOrder.order, self._major_2B, self._minor_2B, self._thisZone_4B, self._sigFigs_4B,self._snapLen_4B,
            self._linkType_4B)

    @staticmethod
    def signature(data):
        """验证签名同时确定排序,虽然此时还未读取到后续大小端"""
        sig = ByteOrder.bytes2int(data)
        if sig == 0xa1b2c3d4:
            ByteOrder.order = "big"
            return True
        elif sig == 0xd4c3b2a1:
            ByteOrder.order = "little"
            return True
        return False


class Packet(object):
    _packet_id = None
    _packetHead_16B = None
    _etherHead_14B = None
    _packet_data = None
    _IPHead = None
    _transportHead = None
    _application = None

    def __init__(self,datas,id):
        print("  Packet Initing")
        self._packet_id = id
        print("  Packet id " + str(id+1))
        self._packet_data = datas
        self._packetHead_16B = PacketHead(self._packet_data[0:16])
        self._packet_data = self._packet_data[16:self._packetHead_16B.get_real_len()+16]
        self._etherHead_14B = EtherHead(self._packet_data[0:14])
        self._packet_data = self._packet_data[14:]
        self._IPHead = IPHead(self._packet_data)
        self._packet_data = self._packet_data[self.get_ip_head().get_ip_len():]
        if self.get_ip_head().get_protocol() == 17:
            self._transportHead = UDPHead(self._packet_data[0:8])
            self._packet_data = self._packet_data[8:]
        elif self.get_ip_head().get_protocol() == 6:
            self._transportHead = TCPHead(self._packet_data)
            self._packet_data = self._packet_data[self._transportHead.get_tcp_len():]
        if len(self._packet_data) != 0:
            Matcher = ApplicationFinder(self._packet_data, self.get_ip_head().get_protocol())
            self._application = Matcher.get_application()

    def get_packet_head(self):
        return self._packetHead_16B

    def get_ether_head(self):
        return self._packetHead_16B

    def get_ip_head(self):
        return self._IPHead


class PacketHead(object):
    _secondTime_4B = None
    _millsecondTime_4B = None
    _captureLen_4B = None
    _realLen_4B = None

    def __init__(self,datas):
        print("    PacketHead Initing")
        self._secondTime_4B =ByteOrder.bytes2int(datas[0:4])
        self._millsecondTime_4B = ByteOrder.bytes2int(datas[4:8])
        self._captureLen_4B = ByteOrder.bytes2int(datas[8:12])
        self._realLen_4B = ByteOrder.bytes2int(datas[12:16])
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "    second:%d millsecond:%d cap_len:%d real_len %d" % (self._secondTime_4B, self._millsecondTime_4B,
                                                                       self._captureLen_4B, self._realLen_4B)

    def get_real_len(self):
        return self._realLen_4B


class EtherHead(object):
    _dst_mac_6B = None
    _src_mac_6B = None
    _type_2B = None

    def __init__(self,datas):
        print("    Ether Initing")
        self._dst_mac_6B = int.from_bytes(datas[0:6],"big")
        self._src_mac_6B = int.from_bytes(datas[6:12],"big")
        self._type_2B = int.from_bytes(datas[12:14],"big")
        #if hex(self._type_2B) == "0x800":
        #   print("IPv4")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return"    mac_src:%012x mac_dst:%012x type:%04x" % (self._src_mac_6B, self._dst_mac_6B, self._type_2B)


class IPHead(object):
    #b是位，B是字节，4b也即是半字节
    _IP_version_4b = None
    _IP_len_4b = None
    _DS_1B = None
    _total_len_2B = None
    _identification_2B = None
    _flag_3b = None
    _deviation_13b = None
    _TTL_1B = None
    _protocol_1B = None
    _check_sum_2B = None
    _srcIp_4B = None
    _dstIp_4B = None

    def __init__(self,datas):
        print("    IPHead Initing")
        self._IP_version_4b = ByteTool.disassembleBytes(datas[0:1], 0, 3)
        self._IP_len_4b = ByteTool.disassembleBytes(datas[0:1], 4, 7) * 4
        self._DS_1B = int.from_bytes(datas[1:2], "big")
        self._total_len_2B = int.from_bytes(datas[2:4], "big")
        self._identification_2B = int.from_bytes(datas[4:6], "big")
        self._flag_3b = ByteTool.disassembleBytes(datas[6:8], 0, 2)
        self._deviation_13b = ByteTool.disassembleBytes(datas[6:8], 3, 15)
        self._TTL_1B = int.from_bytes(datas[8:9], "big")
        self._protocol_1B = int.from_bytes(datas[9:10], "big")
        self._check_sum_2B = int.from_bytes(datas[10:12], "big")
        self._srcIp_4B = int.from_bytes(datas[12:16], "big")
        self._dstIp_4B = int.from_bytes(datas[16:19], "big")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "    version:%d len:%d DS:%d total_len:%d identi:%d flag:%01x deviation:%d TTL:%d protocol:%d " \
               "check_sum:%04x srcIP:%08x dstIP:%08x" % (self._IP_version_4b, self._IP_len_4b, self._DS_1B, self._total_len_2B,
                                          self._identification_2B, self._flag_3b, self._deviation_13b, self._TTL_1B,
                                          self._protocol_1B, self._check_sum_2B, self._srcIp_4B, self._dstIp_4B)

    def get_ip_len(self):
        return self._IP_len_4b

    def get_protocol(self):
        return self._protocol_1B


class UDPHead(object):
    _src_port_2B = None
    _dst_port_2B = None
    _UDP_len_2B = None
    _check_sum_2B = None

    def __init__(self,datas):
        print("    UDP Initing")
        self._src_port_2B = int.from_bytes(datas[0:2], "big")
        self._dst_port_2B = int.from_bytes(datas[2:4], "big")
        self._UDP_len_2B = int.from_bytes(datas[4:6], "big")
        self._check_sum_2B = int.from_bytes(datas[6:8], "big")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return"    srcPort:%d dstPort:%d UDPLen:%d checkSum:%04x" % (self._src_port_2B, self._dst_port_2B,
                                                                   self._UDP_len_2B, self._check_sum_2B)


class TCPHead(object):
    _src_port_2B = None
    _dst_port_2B= None
    _seq_number_4B = None
    _ack_number_4B = None
    _TCP_len_4b = None
    _flag_1B = None
    _window_2B = None
    _check_sum_2B = None
    _urgent_flag_2B = None
    _option = None
    _option_len = None

    def __init__(self,datas):
        print("    TCP Initing")
        self._src_port_2B = int.from_bytes(datas[0:2], "big")
        self._dst_port_2B = int.from_bytes(datas[2:4], "big")
        self._seq_number_4B = int.from_bytes(datas[4:8], "big")
        self._ack_number_4B = int.from_bytes(datas[8:12], "big")
        self._TCP_len_4b = ByteTool.disassembleBytes(datas[12:13], 0, 3) * 4
        self._flag_1B = int.from_bytes(datas[13:14], "big")
        self._window_2B = int.from_bytes(datas[14:16], "big")
        self._check_sum_2B = int.from_bytes(datas[16:18], "big")
        self._urgent_flag_2B = int.from_bytes(datas[18:20], "big")
        self._option_len = self._TCP_len_4b - 20
        self._option = int.from_bytes(datas[20:20+self._option_len], "big")
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return("    src_port:%d dst_port:%d seq_num:%d ack_num:%d Tcp_len:%d flag:%02x win:%d chekc_sum:%d "
               "urgent_flag:%d option_len:%d option:%x") % (self._src_port_2B, self._dst_port_2B, self._seq_number_4B,
                                                            self._ack_number_4B, self._TCP_len_4b, self._flag_1B,
                                                            self._window_2B, self._check_sum_2B, self._urgent_flag_2B,
                                                            self._option_len, self._option)

    def get_tcp_len(self):
        return self._TCP_len_4b


class ApplicationFinder(object):
    _result_application = None
    _application_entity = None
    _application_detail = None
    _application_content = None
    _app_data = None
    _transport_protocol = None
    complete_flag = False

    def __init__(self,datas,transport_protocol):
        self._app_datas = datas
        self._transport_protocol = transport_protocol
        self._application_entity = self.matcher()

    def __str__(self):
        return "    Application:%s" % (self._result_application)

    def matcher(self):
        flag = False
        application_entity = None
        if self._transport_protocol == 6:
            flag,application_entity = self.HTTP_matcher()
            if flag is True:
                return application_entity
            print("    TCP application")
        elif self._transport_protocol == 17:
            print("    UDP application")

    def HTTP_matcher(self):
        data_string = ""
        flag = False
        for app_data in self._app_datas:
            data_string += chr(app_data)
        result_request = re.match('[a-zA-Z]{3,7} .* HTTP/1.[0,1]', data_string)
        result_response = re.match('HTTP/1.[0,1] [0-9]{0,3} *', data_string)
        if (result_request):
            self._result_application = "HTTP"
            self._application_detail = "Request"
            self._application_content = data_string
            flag = True
        elif(result_response):
            self._result_application = "HTTP"
            self._application_detail = "Response"
            self._application_content = data_string
            flag = True
        if flag is True:
            self._application_entity = HttpData(self._application_detail, self._application_content)
        return flag, self._application_entity

    def get_application(self):
        return self._application_entity


class HttpData(object):
    _type = None
    _data = None

    def __init__(self, type, content):
        print("    HTTP Initing")
        self._type = type
        self._data = content
        if INFORM == 1:
            print(self.__str__())

    def __str__(self):
        return "     http_type:%s http_data:%s" % (self._type, self._data)


if __name__ == '__main__':
    bytes = load_pcap("test22.pcap")
    my_pcap_file = PcapFile(bytes)
