# coding=UTF-8
import networkx as nx
from networkx.algorithms.community import k_clique_communities
from networkx import edge_betweenness_centrality
from networkx import edge_betweenness
import matplotlib.pyplot as plt
import math
import re as re
from matplotlib.patches import FancyArrowPatch, Circle
import numpy as np
import matplotlib.patches as mpatches
import db_helper
import statistic_analysis
import Pcap_class
import save_data
import copy
import time
import operator


class GraphSql(object):

    def __init__(self):
        self._sql = ""

    def create_db(self):
        self._sql = "social_network_ip_links"
        db_helper.create_table(self._sql)
        self._sql = "social_network_data"
        db_helper.create_table(self._sql)

    def clear_db(self):
        db_helper.clear_table("social_network_ip_links")
        db_helper.clear_table("social_network_data")

    def write_db(self):
        ip_connect_dict = statistic_analysis.get_ip_connect_dict()
        ip_connect_list = []
        for key in ip_connect_dict:
            connect_list = [0]
            temp_key = list(key)
            connect_list += temp_key
            connect_list += [ip_connect_dict[key]]
            connect_tuple = tuple(connect_list)
            ip_connect_list.append(connect_tuple)
        print("准备提交IP连接数据")
        self._sql = "INSERT INTO social_network_ip_links (Id, Src_IP, Dst_IP, Number) VALUES (%d,%s,%s,%d)"
        db_helper.insert_batch(self._sql, ip_connect_list)


class Graph(object):
    def __init__(self):
        self.G = nx.Graph()
        self.H = nx.Graph()

    def create_undirect_whole_graph(self):
        #sql = "select * from social_network_ip_links"
        sql = "select * from social_network_ip_links_copy"
        results = db_helper.get_data(sql)
        i = 0
        for r in results:
            self.G.add_edge(r[1], r[2], weight=r[3])
            i = i + 1
        print("无向图绘制完成")
        self.save_IP_social_details()

    def draw_all(self):
        weight = []
        #得到G图边列表[(IP1,IP2,weight)...]
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.G.edges(data=True)]
        #将边权重按顺序加入weight列表.需要注意的是,在生成G图时给边的权重和之后生成png时所画出的边的粗细权重是不同的东西,之后会提到
        for edgelist in edgelists:
            row_weight = edgelist[2]                      #取原始数据权重
            weight.append(math.sqrt(row_weight / 10) + 1) #计算绘画粗细的权重
        color = "blue"            #根据IP性质决定点的颜色,返回颜色列表
        pos = nx.spring_layout(self.G, k=2)               #layout决定点的位置,k决定散布距离
        nx.draw_networkx_nodes(self.G, pos, node_size=100, node_color=color)  #画点,确定点位置,点大小,点颜色
        nx.draw_networkx_edges(self.G, pos, edgelists, width=weight)
        #画边,输入边列表,边粗细权重.两个列表必须顺序对应,否则会权重不匹配
        nx.draw_networkx_labels(self.G, pos, font_size=5, font_family='sans-serif') #打标签
        nodes = list(self.G.nodes)      #取G图的点列表
        self.J = self.G.copy()          #复制一份副本至J,便于统一操作分析
        # visualize(G)                  #本来是用于通过web动态生成可拖拽的图,由于兼容性问题,搁置
        plt.axis('off')                 #关闭网格
        timestr = time.strftime("%Y%m%d%H%M%S", time.localtime())+".png"
        plt.savefig(timestr)         #存图
        plt.clf()                       #清空plt,存完图一定要清,不然会重叠.整个作图逻辑是:nx生成图结构,plt作图.两者都应该及时清空,否则会重叠
        return nodes, timestr                    #返回节点列表和图名

    def save_IP_social_details(self):
        nodes = self.G.nodes
        self.node_details = []
        for node in nodes:
            self.node_details.append(self.IP_details(node))
        print("准备提交社会网络数据")
        sql = "INSERT INTO social_network_data(Id, IP, Degree, Degree_centrality, Betweeness_centrality, " \
              "Closeness_centrality, Connections) VALUES (%d,%s,%d,%s,%s,%s,%d)"
        db_helper.insert_batch(sql, self.node_details)

    def IP_details(self, IP):
        mode = 0  # nx的相关指标在全图或连通图内才有意义,暂设为全图下的统计.该参数使IP对指标的分析不受当前显示的图的影响.总基于全图.
        IPs = self.degree(mode)  # 由于nx无法分析单个指定IP,因此先拉出所有点的相关信息,再从相应的元组列表中找到该IP及对应数据
        for IP_degree in IPs:
            if operator.eq(IP, IP_degree[0]) == True:  # 字符串相等,似乎可以直接用'==',IP_degree是元组(IP,data),下同
                temp_degree = IP_degree[1]
                break
        IPs = self.betweeness(mode)
        for IP_betweeness in IPs:
            if operator.eq(IP, IP_betweeness[0]) == True:
                temp_betweeness = round(IP_betweeness[1], 5)
                break
        IPs = self.degree_centrality(mode)
        for IP_centrality in IPs:
            if operator.eq(IP, IP_centrality[0]) == True:
                temp_centrality = round(IP_centrality[1], 5)
                break
        IPs = self.closeness(mode)
        for IP_closeness in IPs:
            if operator.eq(IP, IP_closeness[0]) == True:
                temp_closeness = round(IP_closeness[1], 5)
                break
        IP_temp = [IP]
        IPs = self.connect_nums(IP_temp)
        for IP_connection in IPs:
            if operator.eq(IP, IP_connection[0]) == True:
                temp_connection = IP_connection[1]
                break
        tuple = (0, IP, temp_degree, temp_centrality, temp_betweeness, temp_closeness, temp_connection)
        return tuple

    def degree(self, mode):
        if mode == 0:
            degree_saves = nx.degree(self.G)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank
        elif mode == 1:
            degree_saves = nx.degree(self.H)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank

    def degree_centrality(self, mode):
        if (mode == 0):
            degree_centrality_saves = nx.degree_centrality(self.G)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank
        elif (mode == 1):
            degree_centrality_saves = nx.degree_centrality(self.H)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank

    def betweeness(self, mode):
        if mode == 0:
            betweeness_saves = nx.betweenness_centrality(self.G)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank
        elif mode == 1:
            betweeness_saves = nx.betweenness_centrality(self.H)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank

    def closeness(self, mode):
        if mode == 0:
            closeness_saves = nx.closeness_centrality(self.G)
            order_closeness_rank = sorted(closeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_closeness_rank
        elif mode == 1:
            closeness_saves = nx.closeness_centrality(self.H)
            order_closeness_rank = sorted(closeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_closeness_rank

    def connect_nums(self, IPs):
        sql = ""
        node_list = []
        for IP in IPs:
            sum = 0
            sql = "select Number from social_network_ip_links where Src_IP = '" + IP + "' or Dst_IP = '" + IP + "'"
            results = db_helper.get_data(sql)
            for result in results:
                sum += result[0]
            node_connect = (IP, sum)
            node_list.append(node_connect)
        order_connect_rank = sorted(node_list, key=lambda x: x[1], reverse=True)
        return order_connect_rank

    def get_nodes(self):
        return self.G.nodes

    def get_detail(self):
        return self.node_details

    def k_clique(self):
        nodes_in_community = list(k_clique_communities(self.G, 3))
        all_nodes = []
        for community in nodes_in_community:
            community_nodes = []
            for node in community:
                community_nodes.append(node)
            all_nodes.append(community_nodes)
        colors = ['red', 'yellow', 'green', 'pink', 'orange', 'olive', 'cyan', 'purple']
        nodes_color = []

        def find_node_in_community(IP):
            color_flag = 0
            for community in all_nodes:
                for IP in community:
                    if node == IP:
                        nodes_color.append(colors[color_flag])
                        return
                color_flag += 1
            nodes_color.append("blue")

        for node in self.G.nodes:
            find_node_in_community(node)
        weight = []
        # 得到G图边列表[(IP1,IP2,weight)...]
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.G.edges(data=True)]
        # 将边权重按顺序加入weight列表.需要注意的是,在生成G图时给边的权重和之后生成png时所画出的边的粗细权重是不同的东西,之后会提到
        for edgelist in edgelists:
            row_weight = edgelist[2]  # 取原始数据权重
            weight.append(math.sqrt(row_weight / 10) + 1)  # 计算绘画粗细的权重
        pos = nx.spring_layout(self.G, k=2)  # layout决定点的位置,k决定散布距离
        nx.draw_networkx_nodes(self.G, pos, node_size=100, node_color=nodes_color)  # 画点,确定点位置,点大小,点颜色
        nx.draw_networkx_edges(self.G, pos, edgelists, width=weight)
        # 画边,输入边列表,边粗细权重.两个列表必须顺序对应,否则会权重不匹配
        nx.draw_networkx_labels(self.G, pos, font_size=5, font_family='sans-serif')  # 打标签
        plt.axis('off')  # 关闭网格
        timestr = time.strftime("%Y%m%d%H%M%S", time.localtime()) + ".png"
        plt.savefig(timestr)  # 存图
        plt.clf()  # 清空plt,存完图一定要清,不然会重叠.整个作图逻辑是:nx生成图结构,plt作图.两者都应该及时清空,否则会重叠
        return timestr

    def abnormal_node(self,node_list):
        all_nodes = []
        colors = ['red', 'yellow', 'green', 'pink', 'orange', 'olive', 'cyan', 'purple']
        nodes_color = []

        def find_node(IP):
            if IP in node_list:
                nodes_color.append(colors[0])
            else:
                nodes_color.append("blue")
            return

        for node in self.G.nodes:
            find_node(node)
        weight = []
        # 得到G图边列表[(IP1,IP2,weight)...]
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.G.edges(data=True)]
        # 将边权重按顺序加入weight列表.需要注意的是,在生成G图时给边的权重和之后生成png时所画出的边的粗细权重是不同的东西,之后会提到
        for edgelist in edgelists:
            row_weight = edgelist[2]  # 取原始数据权重
            weight.append(math.sqrt(row_weight / 10) + 1)  # 计算绘画粗细的权重
        pos = nx.spring_layout(self.G, k=2)  # layout决定点的位置,k决定散布距离
        nx.draw_networkx_nodes(self.G, pos, node_size=100, node_color=nodes_color)  # 画点,确定点位置,点大小,点颜色
        nx.draw_networkx_edges(self.G, pos, edgelists, width=weight)
        # 画边,输入边列表,边粗细权重.两个列表必须顺序对应,否则会权重不匹配
        nx.draw_networkx_labels(self.G, pos, font_size=5, font_family='sans-serif')  # 打标签
        plt.axis('off')  # 关闭网格
        timestr = time.strftime("%Y%m%d%H%M%S", time.localtime()) + ".png"
        plt.savefig(timestr)  # 存图
        plt.clf()  # 清空plt,存完图一定要清,不然会重叠.整个作图逻辑是:nx生成图结构,plt作图.两者都应该及时清空,否则会重叠
        return timestr



if __name__ == '__main__':
    #save_data.clear_all_table()

    #my_pcap_file = Pcap_class.build_pcap("necurs3.pcap")
    #print("PcapFile analysing complete")
    #save_data.save_data(my_pcap_file)
    #print("Done")
    #Social_network = GraphSql()
    #Social_network.create_db()
    #Social_network.clear_db()
    #Social_network.write_db()
    Graph = Graph()
    Graph.create_undirect_whole_graph()
    Graph.k_clique()
    Graph.draw_all()
    Graph.Kernighan_Lin()
