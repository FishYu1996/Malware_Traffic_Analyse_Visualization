# coding=UTF-8
import networkx as nx
import matplotlib.pyplot as plt
import math
import re as re
from matplotlib.patches import FancyArrowPatch, Circle
import numpy as np
import matplotlib.patches as mpatches
import Analyser
import instrument


class Graphs():
    G = nx.Graph()  # 总图
    H = nx.Graph()  # 连通子图
    J = nx.Graph()  # 无向图
    L = nx.MultiDiGraph()  # 重图
    weight = []
    abnormal_IP_list = []
    def __init__(self,ID):
        self.H.clear()
        self.J.clear()
        self.L.clear()
        self.weight = []
        print('Initing...'+ str(ID) )

    def create_wholeGraph(self):
        sql = "select * from Link"
        results = Analyser.get_data(sql)
        i = 0
        for r in results:
            self.G.add_edge(r[1], r[2], weight=r[3])
            i = i + 1

    def list_subGraph(self):
        # 取出连通子图列表
        sublist = list(nx.connected_components(self.G))
        nodes = []
        sub_number = 0
        while sub_number < sublist.__len__():
            self.H = self.G.subgraph(list(sublist[sub_number]))
            self.J = self.H.copy()
            IPs = list(self.degree(0))
            sub_number += 1
            nodes.append(IPs[0])
        return nodes

    def draw_all(self):
        sql = "select * from link"
        results = Analyser.get_data(sql)
        i = 0
        weight = []
        for r in results:
            self.G.add_edge(r[1], r[2], weight=r[3])
            i = i + 1
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.G.edges(data=True)]
        for edgelist in edgelists:
            row_weight = edgelist[2]
            weight.append(math.sqrt(row_weight / 10) + 1)
        color = self.decide_node_color(self.G)
        pos = nx.spring_layout(self.G, k=2)  # positions for all nodes
        nx.draw_networkx_nodes(self.G, pos, node_size=100, node_color=color)
        nx.draw_networkx_edges(self.G, pos, edgelists, width=weight)
        nx.draw_networkx_labels(self.G, pos, font_size=5, font_family='sans-serif')
        nodes = list(self.G.nodes)
        self.J = self.G.copy()
        # visualize(G)
        plt.axis('off')
        plt.savefig("test.png")
        plt.clf()
        return nodes

    def draw_SingleIP(self,IP):
        global abnormal_IP_list
        abnormal_IP_list = Analyser.read_abnormal_IP_list()
        if not IP in abnormal_IP_list:
            nodes = self.draw_normal_SingleIP(IP)
        elif IP in abnormal_IP_list:
            nodes = self.draw_abnormal_SingleIP(IP)
        return nodes

    def draw_normal_SingleIP(self,IP):
        self.J.clear()
        sql = "select * from Link where IP1='" + IP + "'or IP2='" + IP + "'"
        results = Analyser.get_data(sql)
        i = 0
        weight = []
        for r in results:
            self.J.add_edge(r[1], r[2], weight=r[3])
            i = i + 1
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.J.edges(data=True)]
        for edgelist in edgelists:
            row_weight = edgelist[2]
            weight.append(math.sqrt(row_weight / 10) + 1)
        color = self.decide_node_color(self.J)
        pos = nx.spring_layout(self.J, k=1)  # positions for all nodes
        nx.draw_networkx_nodes(self.J, pos, node_size=200, node_color=color)
        nx.draw_networkx_edges(self.J, pos, edgelists, width=weight)
        nx.draw_networkx_labels(self.J, pos, font_size=5, font_family='sans-serif')
        nodes = list(self.J.nodes)
        plt.axis('off')
        # plt.show()
        plt.savefig("test.png")
        plt.clf()
        return nodes

    def draw_abnormal_SingleIP(self,IP):
        # to-do
        self.L.clear()
        self.J.clear()
        abnormal_IPs_detail_dict = instrument.create_abnormal_IPs_dict(self,abnormal_IP_list)
        sql = "select * from Link where IP1='" + IP + "'or IP2='" + IP + "'"
        results = Analyser.get_data(sql)
        i = 0
        for r in results:
            self.J.add_edge(r[1], r[2], sty=5, width=1)
            if r[1] in abnormal_IP_list and r[2] in abnormal_IP_list:
                role = abnormal_IPs_detail_dict[r[1]]['flawedAmy']
                Amy_Attribution_dict = Analyser.Necurs_flaw_Amy_Attribution(r[1], role)
                Amy_Attribution_list = ['download_batch_1', 'download_batch_2', 'download_prefile', 'download_file']
                label = 1
                for Amy_Attribution in Amy_Attribution_list:
                    int_packet_length = int(Amy_Attribution_dict[Amy_Attribution])
                    if int_packet_length != 0:
                        if role == 'C&C Server':
                            self.L.add_edge(r[1], r[2], sty=label, width=1)
                        elif role == 'Infected':
                            self.L.add_edge(r[2], r[1], sty=label, width=1)
                    label += 1
            elif not (r[1] in abnormal_IP_list and r[2] in abnormal_IP_list):
                self.L.add_edge(r[1], r[2], sty=5, width=1)
                i = i + 1
        pos = nx.spring_layout(self.L, threshold=0.2)
        ax = plt.gca()
        self.draw_MultipleLine(self.L, pos, ax)
        ax.autoscale()

        color_example = []
        red_patch = mpatches.Patch(color='red', label='DNS')
        color_example.append(red_patch)
        blue_patch = mpatches.Patch(color='blue', label='HTTP')
        color_example.append(blue_patch)
        black_patch = mpatches.Patch(color='black', label='HTTPS')
        color_example.append(black_patch)
        yellow_patch = mpatches.Patch(color='yellow', label='TCP')
        color_example.append(yellow_patch)
        green_patch = mpatches.Patch(color='green', label='UDP')
        color_example.append(green_patch)
        plt.legend(handles=color_example)

        nx.draw_networkx_labels(self.L, pos, font_size=5, font_family='sans-serif')
        nodes = list(self.L.nodes)
        plt.axis('equal')
        plt.axis('off')
        plt.savefig("test.png")
        plt.clf()
        plt.close('all')
        return nodes

    # 输入模式，返回元组列表:[(IP,值),...]
    def degree(self,mode):
        if mode == 0:
            degree_saves = nx.degree(self.G)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank
        elif mode == 1:
            degree_saves = nx.degree(self.H)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank
        elif mode == 2:
            degree_saves = nx.degree(self.J)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank

    def betweeness(self,mode):
        if mode == 0:
            betweeness_saves = nx.betweenness_centrality(self.G)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank
        elif mode == 1:
            betweeness_saves = nx.betweenness_centrality(self.H)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank
        elif mode == 2:
            betweeness_saves = nx.betweenness_centrality(self.J)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank

    def degree_centrality(self,mode):
        if (mode == 0):
            degree_centrality_saves = nx.degree_centrality(self.G)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank
        elif (mode == 1):
            degree_centrality_saves = nx.degree_centrality(self.H)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank
        elif (mode == 2):
            degree_centrality_saves = nx.degree_centrality(self.J)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank

    def change_subgraph(self,id):
        sublist = list(nx.connected_components(self.G))
        weight = []
        self.H = self.G.subgraph(list(sublist[id]))
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.H.edges(data=True)]
        for edgelist in edgelists:
            row_weight = edgelist[2]
            weight.append(math.sqrt(row_weight / 10) + 1)
        color = self.decide_node_color(self.H)
        pos = nx.spring_layout(self.H, k=1)  # positions for all nodes
        nx.draw_networkx_nodes(self.H, pos, node_size=200, node_color=color)
        nx.draw_networkx_edges(self.H, pos, width=weight)
        nx.draw_networkx_labels(self.H, pos, font_size=5, font_family='sans-serif')
        plt.axis('off')
        plt.savefig("test.png")
        plt.clf()
        self.J = self.H.copy()

    def transfer_all_nodes(self):
        return list(self.G.nodes)

    def transfer_nodes(self):
        return list(self.J.nodes)

    def transfer_subnodes(self):
        return list(self.H.nodes)


    def draw_Line(self,IP1, IP2):
        i = 0
        while i < 2:
            if i == 0:
                srcIP = IP1
                dstIP = IP2
            elif i == 1:
                srcIP = IP2
                dstIP = IP1
            protocols = Analyser.Link_Protocol_Analyse(srcIP, dstIP, 1)
            protocol_proper = []
            protocol_label = 1
            for protocol in protocols:
                string = str(protocol)
                inform = re.split(r"/|", string)
                int_protocol_proper = int(inform[0])
                if int_protocol_proper != 0:
                    self.L.add_edge(srcIP, dstIP, sty=protocol_label, width=(math.sqrt(int_protocol_proper)) / 3)
                protocol_label += 1
            i += 1
        pos = nx.spring_layout(self.L)
        ax = plt.gca()
        self.draw_MultipleLine(self.L, pos, ax)
        ax.autoscale()

        color_example = []
        red_patch = mpatches.Patch(color='red', label='DNS')
        color_example.append(red_patch)
        blue_patch = mpatches.Patch(color='blue', label='HTTP')
        color_example.append(blue_patch)
        black_patch = mpatches.Patch(color='black', label='HTTPS')
        color_example.append(black_patch)
        yellow_patch = mpatches.Patch(color='yellow', label='TCP')
        color_example.append(yellow_patch)
        green_patch = mpatches.Patch(color='green', label='UDP')
        color_example.append(green_patch)
        plt.legend(handles=color_example)

        nx.draw_networkx_labels(self.L, pos, font_size=5, font_family='sans-serif')
        self.L.clear()
        plt.axis('equal')
        plt.axis('off')
        plt.savefig("Line.png")
        plt.clf()
        plt.close('all')

    def draw_MultipleLine(self,L, pos, ax, sg=None):
        for n in L:
            c = Circle(pos[n], radius=0.05, alpha=0.7)
            ax.add_patch(c)
            L.node[n]['patch'] = c
            x, y = pos[n]
        seen = {}
        for (u, v, d) in L.edges(data=True):
            n1 = L.node[u]['patch']
            n2 = L.node[v]['patch']
            rad = 0.1 * 3
            if (u, v) in seen:
                rad = seen.get((u, v))
                rad = (rad + np.sign(rad) * 0.1) * -1
            alpha = 0.5
            style = d['sty']
            if style == 1:
                color = 'r'
            elif style == 2:
                color = 'b'
            elif style == 3:
                color = 'k'
            elif style == 4:
                color = 'y'
            elif style == 5:
                color = 'g'

            width = d['width']
            line = width
            e = FancyArrowPatch(n1.center, n2.center, patchA=n1, patchB=n2,
                                arrowstyle='-|>',
                                connectionstyle='arc3,rad=%s' % rad,
                                mutation_scale=10.0,
                                lw=2,
                                alpha=alpha,
                                color=color)
            e.set_linewidth(line)
            e.set_label(line)
            seen[(u, v)] = rad
            ax.add_patch(e)
        return e

    def decide_node_color(self,H):
        flag = 0
        global abnormal_IP_list
        abnormal_IP_list = Analyser.read_abnormal_IP_list()
        color = []
        for node in H.nodes:
            for abnormal_IP in abnormal_IP_list:
                IP = abnormal_IP
                if node == IP:
                    color.append('r')
                    flag = 1
                    break
            if flag != 1:
                color.append('b')
            else:
                flag = 0
        return color

    def test_transfer_Graph(self):
        return self.G


