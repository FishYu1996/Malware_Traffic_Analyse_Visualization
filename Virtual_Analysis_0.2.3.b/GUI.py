# coding=UTF-8
from tkinter import *
from PIL import Image, ImageTk
import Analyser
#import Draw_Graph
import operator
import instrument
from Graphs_Class import Graphs

'''
Date: 2018/11/28
Author:YuJunjie
Describe:This's the class for GUI
'''
GUI_ID = 0 #标记窗口ID，暂无用
abnormal_IPs_list=[] #异常IP列表
abnormal_Links_list=[] #所有与异常IP有关的连接。为元组列表:[(IP1,IP2,连接数),...]
abnormal_IPs_detail_dict={} #所有异常IP的详细字典。为字典的字典:{IP1:{特征:数据,...},IP2:{特征:数据,...}...}

#GUI类
class App():
    load_in_flag = 0 #导入标记，0未导入，1导入
    flag_for_section = 0 #板块标记,0全局分析,1连通图分析,2单点分析,3暂无,4异常点分析
    '''
    # 初始化生成窗口.
    # 参数root判断是主GUI还是子GUI,若为子GUI,传输绝对根.
    # 参数IP传输子GUI要表示的核心IP
    '''
    def __init__(self,root = None,IP = None):
        self.GUI_ID = GUI_ID #获取自身GUI_ID
        self.graphs = Graphs(self.GUI_ID) #生成Graphs类用于完成各种图方法
        #root为空，说明是主GUI
        if root == None:
            #创建根容器
            self.IP = None #主GUI无核心IP
            self.root = Tk() #创建容器
            self.final_root=self.root #将容器作为整个GUI的绝对根
            self.root.title("APP")
            #创建菜单栏
            menu = Menu(self.root)
            self.root.config(menu=menu)# 创建“系统”子菜单
            #第一子菜单栏
            submenu=Menu(menu,tearoff=0)
            submenu.add_command(label="导入",command=self.Load_In)
            submenu.add_separator()
            submenu.add_command(label="退出",command=self.root.quit)
            menu.add_cascade(label="系统",menu=submenu)
            #第二子菜单栏
            submenu=Menu(menu,tearoff=0)
            submenu.add_command(label="总图分析",command=self.All_Analyse)
            menu.add_cascade(label="总图信息",menu=submenu)
            #第三子菜单栏
            submenu = Menu(menu, tearoff=0)
            submenu.add_command(label="连通图")
            menu.add_cascade(label="连通图分析", menu=submenu)
            #第四子菜单栏
            submenu = Menu(menu, tearoff=0)
            submenu.add_command(label="所有异常IP")
            submenu.add_command(label="含dga域名")
            submenu.add_command(label="Necurs_Ammyy模式")
            menu.add_cascade(label="异常模式分析", menu=submenu)
        #root不为空,说明是子GUI
        else :
            self.final_root = root    #绝对根以参数而非生成的形式传输给子GUI,保证子GUI是依附于主GUI存在的
            self.flag_for_section = 2 #子GUI有核心IP,是针对单点分析而产生的，因此取2
            self.load_in_flag = 1     #子GUI无需再导入，直接置1
            self.IP = IP              #记录核心IP
            self.root = Toplevel(root, width=800, height=800) #生成子GUI
            self.root.title(IP)
            self.root.attributes('-topmost', 1)

        #主视图
        self.lb1 = LabelFrame(self.root, width=800, height=950, text='视图')
        self.lb1.grid(row=0, column=0, padx=15,rowspan=2)
        #初始化填充背景
        self.img = Image.open('cover1.png')  # 打开背景图片
        self.photo = ImageTk.PhotoImage(self.img)  # 用PIL模块的PhotoImage打开
        self.Label_Image = Label(self.lb1, width=780, height=900,image=self.photo)
        self.Label_Image.place(x=5,y=0)
        #点信息控制区
        self.lb2= LabelFrame(self.root, width=500, height=460, text='点信息控制')
        self.lb2.grid(row=0, column=1, padx=15)
        self.control_title=Label(self.lb2,text='请选择')
        self.control_title.place(x=130,y=0)
        self.control_tip = Label(self.lb2, text='IP节点                                    点的可疑等级')
        self.control_tip.place(x=60, y=40)
        #点列表
        self.ip_listbox=Listbox(self.lb2,width=50,height=10)
        self.ip_listbox.place(x=10,y=65)
        self.ip_listbox.bind("<<ListboxSelect>>", self.show_msg)
        #按钮们
        self.certain_button = Button(self.lb2,width=10,text="确定",command=self.menu_select)
        self.certain_button.place(x=50,y=300)
        self.return_button = Button(self.lb2,width=10, text="返回",command=self.menu_return)
        self.return_button.place(x=180,y=300)
        #单选框选择排序方式
        self.rad_1 = IntVar()
        self.rad_1.set(0)
        self.Order = ["度","介数中心性","点度中心性","连接数","小包占比","可疑度"]
        for col in range(2):
            for col2 in range(3):
                Order_Rad = Radiobutton(self.lb2, text=self.Order[col*3+col2], variable=self.rad_1, value=col*3+col2,
                            command=self.radCall)
                Order_Rad.place(x=130 * col2+20, y=350+col*50)
        #边信息控制区
        self.lb5 = LabelFrame(self.root, width=500, height=460, text='边信息控制')
        self.lb5.grid(row=1, column=1, padx=15,)
        self.control_title_2 = Label(self.lb5, text='请选择')
        self.control_title_2.place(x=130, y=0)
        self.control_tip_2 = Label(self.lb5, text='边                                 连接数   ')
        self.control_tip_2.place(x=60, y=40)
        #边列表
        self.ip_listbox_2 = Listbox(self.lb5, width=50, height=10)
        self.ip_listbox_2.place(x=10, y=65)
        self.ip_listbox_2.bind("<<ListboxSelect>>", self.show_msg_2)
        #按钮们
        self.certain_button_2 = Button(self.lb5, width=10, text="确定", command=self.menu_select_2)
        self.certain_button_2.place(x=50, y=300)
        self.return_button_2 = Button(self.lb5, width=10, text="返回", command=self.menu_return_2)
        self.return_button_2.place(x=180, y=300)
        #单选框选择边排序方式
        self.Order = ["1", "2", "3", "4", "5", "6"]
        self.rad_2 = IntVar()
        self.rad_2.set(0)
        for col in range(2):
            for col2 in range(3):
                Order_Rad = Radiobutton(self.lb5, text=self.Order[col * 3 + col2], variable=self.rad_2,
                                        value=col * 3 + col2,
                                        command=self.radCall_Line)
                Order_Rad.place(x=130 * col2 + 20, y=350 + col * 50)
        #点信息显示区
        self.lb3 = LabelFrame(self.root, width=400, height=460, text='点信息显示')
        self.lb3.grid(row=0, column=2, padx=15)
        self.inform_text_x=100
        self.inform_Text0 = Label(self.lb3, text="度")
        self.inform_Text0.place(x=self.inform_text_x * 0 + 30, y=0 * 40 +5)
        self.inform_Text1 = Label(self.lb3, text=0)
        self.inform_Text1.place(x=self.inform_text_x * 1 + 30, y=0 * 40 + 5)
        self.inform_Text2 = Label(self.lb3, text="介数中心性")
        self.inform_Text2.place(x=self.inform_text_x * 0 + 30, y=1 * 40 + 5)
        self.inform_Text3 = Label(self.lb3, text=0)
        self.inform_Text3.place(x=self.inform_text_x * 1 + 30, y=1 * 40 + 5)
        self.inform_Text4 = Label(self.lb3, text="点度中心性")
        self.inform_Text4.place(x=self.inform_text_x * 0 + 30, y=2 * 40 + 5)
        self.inform_Text5 = Label(self.lb3, text=0)
        self.inform_Text5.place(x=self.inform_text_x * 1 + 30, y=2 * 40 + 5)
        self.inform_Text6 = Label(self.lb3, text="连接数")
        self.inform_Text6.place(x=self.inform_text_x * 0 + 30, y=3 * 40 + 5)
        self.inform_Text7 = Label(self.lb3, text=0)
        self.inform_Text7.place(x=self.inform_text_x * 1 + 30, y=3 * 40 + 5)
        self.inform_Text8 = Label(self.lb3, text="小包占比")
        self.inform_Text8.place(x=self.inform_text_x * 0 + 30, y=4 * 40 + 5)
        self.inform_Text9 = Label(self.lb3, text=0)
        self.inform_Text9.place(x=self.inform_text_x * 1 + 30, y=4 * 40 + 5)
        self.inform_Text10 = Label(self.lb3, text="dga")
        self.inform_Text10.place(x=self.inform_text_x * 0 + 30, y=5 * 40 + 5)
        self.inform_Text11 = Label(self.lb3, text='No')
        self.inform_Text11.place(x=self.inform_text_x * 1 + 30, y=5 * 40 + 5)
        self.inform_Text12 = Label(self.lb3, text="FlawedAmy")
        self.inform_Text12.place(x=self.inform_text_x * 0 + 30, y=6 * 40 + 5)
        self.inform_Text13 = Label(self.lb3, text='Null')
        self.inform_Text13.place(x=self.inform_text_x * 1 + 30, y=6 * 40 + 5)
        #边信息显示区
        self.lb4 = LabelFrame(self.root, width=400, height=460, text='边信息显示')
        self.lb4.grid(row=1, column=2, padx=15)
        self.spe_inform_text_x = 100
        self.spe_inform_Text0 = Label(self.lb4, text="连接数")
        self.spe_inform_Text0.place(x=self.spe_inform_text_x * 0 + 20, y=0 * 40 + 5)
        self.spe_inform_Text1 = Label(self.lb4, text=0)
        self.spe_inform_Text1.place(x=self.spe_inform_text_x * 1 + 20, y=0 * 40 + 5)
        self.spe_inform_Text2 = Label(self.lb4, text="小包数/占比")
        self.spe_inform_Text2.place(x=self.spe_inform_text_x * 0 + 20, y=1 * 40 + 5)
        self.spe_inform_Text3 = Label(self.lb4, text=0)
        self.spe_inform_Text3.place(x=self.spe_inform_text_x * 1 + 20, y=1 * 40 + 5)
        self.spe_inform_Text4 = Label(self.lb4, text="大包数/占比")
        self.spe_inform_Text4.place(x=self.spe_inform_text_x * 0 + 20, y=2 * 40 + 5)
        self.spe_inform_Text5 = Label(self.lb4, text=0)
        self.spe_inform_Text5.place(x=self.spe_inform_text_x * 1 + 20, y=2 * 40 + 5)
        self.spe_inform_Text6 = Label(self.lb4, text="DNS")
        self.spe_inform_Text6.place(x=self.spe_inform_text_x * 0 + 20, y=3 * 40 + 5)
        self.spe_inform_Text7 = Label(self.lb4, text=0)
        self.spe_inform_Text7.place(x=self.spe_inform_text_x * 1 + 20, y=3 * 40 + 5)
        self.spe_inform_Text8 = Label(self.lb4, text="HTTP")
        self.spe_inform_Text8.place(x=self.spe_inform_text_x * 0 + 20, y=4 * 40 + 5)
        self.spe_inform_Text9 = Label(self.lb4, text=0)
        self.spe_inform_Text9.place(x=self.spe_inform_text_x * 1 + 20, y=4 * 40 + 5)

        #如果为子GUI,为了避免Graphs中图的互相影响，需要先在子GUI中留存A-J,B-L的私有备份
        if self.IP != None:
            self.Single_Analyse(IP)       #根据核心IP展开分析
            self.A = self.graphs.J.copy() #深copy
            self.B = self.graphs.L.copy()
            self.IP_details(self.IP)      #显示核心IP相关信息
            self.flag_for_section = 2     #冗余代码-事实上标志已经置2


    # 所有点分析-基于数据库-存于G图
    def All_Node_Analyse(self):
            if self.load_in_flag == 1:
                self.control_title.config(text="所有节点")
                self.control_tip.config(text='IP节点                                    点的度')
                self.graphs.draw_all()             #生成G图及png图片
                self.Load_img('test.png')          #处理、打开、加载png图片
                self.Rank(self.graphs.degree(0))   #按照'度'将点在上方列表框排序显示,Rank缺省参数0表示上方的列表框.
                                                   # degree参数表示基于不同的图,详见degree函数


    # 所有边分析-基于数据库
    def All_Link_Analyse(self):
            if self.load_in_flag == 1:
                self.control_title_2.config(text="所有边")
                self.control_tip_2.config(text='IP对                                    连接数')
                self.spe_inform_Text0.config(text="连接数")
                self.spe_inform_Text1.config(text="0")
                self.spe_inform_Text2.config(text="小包数/占比")
                self.spe_inform_Text3.config(text="0/0")
                self.spe_inform_Text4.config(text="大包数/占比")
                self.spe_inform_Text5.config(text="0/0")
                self.spe_inform_Text6.config(text="DNS/占比")
                self.spe_inform_Text7.config(text="0/0")
                self.spe_inform_Text8.config(text="HTTP/占比")
                self.spe_inform_Text9.config(text="0/0")
                self.Rank(Analyser.Link_Connections(),1) #统计所有边,及其数量并排序在下方列表框显示


    # 总图分析入口-分别调用点和边分析,并将板块标志置0
    def All_Analyse(self):
        self.All_Node_Analyse()
        self.All_Link_Analyse()
        self.flag_for_section=0


    # 基于单点.从点的角度进行分析,输入参数为核心IP
    def Single_Node_Analyse(self,IP):
        self.control_title.config(text="所有节点")
        self.control_tip.config(text='IP节点                                    点的度')
        self.graphs.draw_SingleIP(IP)     #画单点展开图-存于J图或L图
        self.Load_img('test.png')
        self.Rank(self.graphs.degree(2))

    '''
    # 基于单点,从边的角度进行分析,暂未开工
    def Single_Link_Analyse(self):
        self.Rank(Analyser.Node_Links_Analyse(IPs), 1)
    '''


    #单点分析入口
    def Single_Analyse(self,IP):
        self.Single_Node_Analyse(IP)
        #self.Single_Link_Analyse()


    # 导入数据，显示可疑IP和可疑度
    def Load_In(self):
        #导入过程中需要为异常IP的三个数据结构写入数据
        global abnormal_Links_list
        global abnormal_IPs_list
        global abnormal_IPs_detail_dict
        self.graphs.create_wholeGraph()  #生成G图,但不生成png
        abnormal_IPs_Rank = Analyser.abnormal_modes_analyse()  #执行异常IP判断程序,详见该函数.返回排序后的[(异常IP,异常数)...]
        self.Rank(abnormal_IPs_Rank,0)   #显示至上部列表框
        abnormal_IPs_list=Analyser.read_abnormal_IPs()  #读取异常IP列表
        abnormal_Links_list=Analyser.abnormal_links(abnormal_IPs_list) #读取异常IP连接列表
        Links_list=instrument.change_IPs_to_Links_str(abnormal_Links_list)  #将异常IP连接列表中的两个IP拼接成字符串.最终返回字符串列表
        data_list=[]   #存异常IP连接列表中的连接数数据,由于其和Links_list均从一个列表中顺序读取,因此是一一匹配的.
        for abnormal_Link in abnormal_Links_list:  #取数据的过程
            data_list.append(abnormal_Link[2])
        Links_dic=instrument.change_list_to_dict(Links_list,data_list)#输入两个列表,将其一一匹配的保存为字典格式:{IP字符串:连接数,...}
        order_Links_Ranks = sorted(Links_dic.items(), key=lambda x: x[1], reverse=True)#按照连接数重新排序字典,排序保存为[(IP字符串,连接数)...]
        self.Rank(order_Links_Ranks,1)  #显示至下部列表框
        self.load_in_flag = 1           #导入完毕,标记置1
        # 生成异常IP详细字典,由于需要用到graph的相关指标，输入参数需要graphs对象和异常IP的列表,具体过程详见函数部分
        abnormal_IPs_detail_dict=instrument.create_abnormal_IPs_dict(self.graphs,abnormal_IPs_list)
        self.flag_for_section=4         #导入后默认为异常IP分析模块


    # 点列表选中事件
    def show_msg(self,*args):
        string = str(self.ip_listbox.get(self.ip_listbox.curselection()[0]))
        IP = re.split(r"->| ", string)
        self.IP_details(IP[0])
        self.control_title.config(text=IP[0])


    def menu_select(self):
        if self.load_in_flag == 1:
            global GUI_ID
            GUI_ID += 1
            string = str(self.ip_listbox.get(self.ip_listbox.curselection()[0]))
            string_part = string.split()
            w1 = App(self.final_root,string_part[0])
            self.certain_button.wait_window(w1.root)
        print("select")


    def menu_return(self):
        print("return")


    def radCall(self):
        radSelect = self.rad_1.get()
        if self.flag_for_section!=4:
            if self.flag_for_section == 2:
                self.graphs.J = self.A.copy()
                self.graphs.L = self.B.copy()
            if radSelect == 0:
                self.control_tip.config(text="IP节点                                点的度")
                IPs_to_show=list(self.graphs.degree(self.flag_for_section))
                self.Rank(IPs_to_show)
            elif radSelect == 1:
                self.control_tip.config(text="IP节点                                介数中心性")
                IPs_to_show = list(self.graphs.betweeness(self.flag_for_section))
                self.Rank(IPs_to_show)
            elif radSelect == 2:
                self.control_tip.config(text="IP节点                                点度中心性")
                IPs_to_show = list(self.graphs.degree_centrality(self.flag_for_section))
                self.Rank(IPs_to_show)
            elif radSelect == 3:
                self.control_tip.config(text="IP节点                                连接数")
                IPs_to_show=self.graphs.transfer_nodes()
                self.Rank(Analyser.Node_Links_Analyse(IPs_to_show))
            elif radSelect == 4:
                self.control_tip.config(text="IP节点                                小包占比")
                IPs_to_show = self.graphs.transfer_nodes()
                self.Rank(Analyser.Node_Length_Analyse(IPs_to_show))
            elif radSelect == 5:
                self.control_tip.config(text="IP节点                                怀疑度")
                if self.flag_for_section == 0:
                    IPs_suspicious_degree=instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "suspicious_degree")
                    IPs_to_show = self.graphs.transfer_all_nodes()
                    for IP in IPs_to_show:
                        if IP not in abnormal_IPs_list:
                            IP_suspicious_degree_tuple=(IP,0)
                        IPs_suspicious_degree.append(IP_suspicious_degree_tuple)
                    self.Rank(IPs_suspicious_degree)
                else:
                    IPs_to_show = self.graphs.transfer_nodes()
                    IPs_suspicious_degree = []
                    for IP in IPs_to_show:
                        if IP not in abnormal_IPs_list:
                            IP_suspicious_degree_tuple=(IP,0)
                            IPs_suspicious_degree.append(IP_suspicious_degree_tuple)
                        else:
                            IP_suspicious_degree_tuple = (IP, abnormal_IPs_detail_dict[IP]['suspicious_degree'])
                            IPs_suspicious_degree.append(IP_suspicious_degree_tuple)
                    order_suspicious_rank = sorted(IPs_suspicious_degree, key=lambda x: x[1], reverse=True)
                    self.Rank(order_suspicious_rank)

        elif self.flag_for_section==4:
            if radSelect == 0:
                self.control_tip.config(text="IP节点                                点的度")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict,"degree"))
            elif radSelect == 1:
                self.control_tip.config(text="IP节点                                介数中心性")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict,"betweeness"))
            elif radSelect == 2:
                self.control_tip.config(text="IP节点                                点度中心性")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict,"centrality"))
            elif radSelect == 3:
                self.control_tip.config(text="IP节点                                连接数")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "link"))
            elif radSelect == 4:
                self.control_tip.config(text="IP节点                                小包占比")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "length_prop"))
            elif radSelect == 5:
                self.control_tip.config(text="IP节点                                怀疑度")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "suspicious_degree"))


    def show_msg_2(self,*args):
        string = str(self.ip_listbox_2.get(self.ip_listbox_2.curselection()[0]))
        IP = re.split(r"->| ", string)
        self.Link_details(IP[0], IP[1])
        self.control_title_2.config(text=IP[0]+"->"+IP[1])


    def menu_select_2(self):
        print(self.A.nodes)
        print("select")


    def menu_return_2(self):
        print("return")


    def radCall_Line(self):
        print("radCall")


    def Rank(self,Informs,type=0):
        '''
        :param Informs: data to be ranked
        :param type: [(IP,data),...]
        :return:
        '''
        if type==0:
            self.ip_listbox.delete(0, 'end')
            for Inform in Informs:
                format_string = "%(IP)-40s%(Count) 8.2f" % {'IP': Inform[0], 'Count': Inform[1]}
                self.ip_listbox.insert('end', format_string)
            self.ip_listbox.select_set(0)
        elif type==1:
            self.ip_listbox_2.delete(0, 'end')
            for Inform in Informs:
                format_string = "%(IP)-40s%(Count) 8.2f" % {'IP': Inform[0], 'Count': Inform[1]}
                self.ip_listbox_2.insert('end', format_string)
            self.ip_listbox_2.select_set(0)


    def IP_details(self,IP):
        mode=0
        IPs=self.graphs.degree(mode)
        for IP_degree in IPs:
            if operator.eq(IP,IP_degree[0])==True:
                self.inform_Text0.config(text="度")
                self.inform_Text1.config(text=IP_degree[1])
                break
        IPs = self.graphs.betweeness(mode)
        for IP_betweeness in IPs:
            if operator.eq(IP,IP_betweeness[0])==True:
                self.inform_Text2.config(text="介数中心性")
                self.inform_Text3.config(text=round(IP_betweeness[1],5))
                break
        IPs = self.graphs.degree_centrality(mode)
        for IP_centrality in IPs:
            if operator.eq(IP, IP_centrality[0])==True:
                self.inform_Text4.config(text="点度中心性")
                self.inform_Text5.config(text=round(IP_centrality[1],5))
                break
        IP_list=[]
        IP_list.append(IP)
        self.inform_Text6.config(text="连接数")
        self.inform_Text8.config(text="小包占比")
        self.inform_Text7.config(text=Analyser.Node_Links_Analyse(IP_list)[0][1])
        self.inform_Text9.config(text=round(Analyser.Node_Length_Analyse(IP_list)[0][1],5))
        if IP in abnormal_IPs_detail_dict.keys():
            self.inform_Text11.config(text=abnormal_IPs_detail_dict[IP]['dga'])
            self.inform_Text13.config(text=abnormal_IPs_detail_dict[IP]['flawedAmy'])
        else:
            self.inform_Text11.config(text="No")
            self.inform_Text13.config(text="Null")


    def Link_details(self,IP1,IP2):
        self.spe_inform_Text1.config(text=Analyser.Link_Connection(IP1,IP2))
        String=Analyser.Link_Length_Analyse(IP1,IP2)
        self.spe_inform_Text3.config(text=String[0])
        self.spe_inform_Text5.config(text=String[1])
        String=Analyser.Link_Protocol_Analyse(IP1,IP2)
        self.spe_inform_Text7.config(text=String[0])
        self.spe_inform_Text9.config(text=String[1])


    def Mainloop(self):
        self.root.mainloop()


    def Load_img(self,name):
        self.img = Image.open(name)  # 打开图片
        w_box = 780
        h_box = 900
        img_resized = self.resize(w_box, h_box, self.img)  # 缩放图像让它保持比例，同时限制在一个矩形框范围内  【调用函数，返回整改后的图片】
        self.photo = ImageTk.PhotoImage(img_resized)  # 用PIL模块的PhotoImage打开
        self.Label_Image.config(image=self.photo)
        self.Label_Image.image = self.photo


    def resize(self,w_box, h_box, pil_image):  # 参数是：要适应的窗口宽、高、Image.open后的图片
        w, h = pil_image.size  # 获取图像的原始大小
        f1 = 1.0 * w_box / w
        f2 = 1.0 * h_box / h
        factor = min([f1, f2])
        width = int(w * factor)
        height = int(1.5*h * factor)
        return pil_image.resize((width, height), Image.ANTIALIAS)


def read_abnormal_abnormal_IPs_detail_dict():
    return abnormal_IPs_detail_dict


app = App()
app.Mainloop()

