# coding=UTF-8
from util import ByteOrder,ByteTool
'''
没法处理太大的包
'''


def load_pcap(file_name):
    f = open(file_name,'rb')
    n = 0
    TEST = 0
    bytes = []
    s = f.read(1)
    while s:
        bytes.append(ord(s))
        n = n + 1
        s = f.read(1)
    print("Loading......")
    print('total bytes: %d'%n)
    f.close()
    if(TEST == 1):
        n = 0
        for byte in bytes:
            n = n + 1
            print('0x%02x,' % (byte), end='')
            if n % 16 == 0:
                print('')
            if n > 160:
                break
        print('')
    return bytes


class PcapFile(object):
    _raw_data = None
    _pcap_head = None
    _packets = []

    def __init__(self, bytes):
        print("Pcap Initing")
        self._raw_data = bytes
        self._change_data = bytes
        if self._pcap_head is None:
            self.fill_pcap_head(self._change_data)
            self._change_data = self._change_data[24:]
        while len(self._change_data) > 0:
            packet = Packet(self._change_data)
            self._packets.append(packet)
            self._change_data =self._change_data[packet.get_packet_head().get_real_len()+16:]
        print(len(self._packets))

    def fill_pcap_head(self, data):
        data = data[0:24]
        self._pcap_head = PcapHead(data)


class PcapHead(object):
    _magic_4B = None
    _major_2B = None
    _minor_2B = None
    _thisZone_4B = None
    _sigFigs_4B = None
    _snapLen_4B = None
    _linkType_4B = None

    def __init__(self, datas):
        print("  PcapHead Initing")
        self._magic_4B = datas[0:4]
        if PcapHead.signature(self._magic_4B) is False:
            raise Exception("不支持的文件格式")
        self._major_2B = ByteOrder.bytes2int(datas[4:6])
        self._minor_2B = ByteOrder.bytes2int(datas[6:8])
        self._thisZone_4B = ByteOrder.bytes2int(datas[8:12])
        self._sigFigs_4B = ByteOrder.bytes2int(datas[12:16])
        self._snapLen_4B = ByteOrder.bytes2int(datas[16:20])
        self._linkType_4B = ByteOrder.bytes2int(datas[20:24])
        #print(self.__str__())

    def __str__(self):
        return "  order:%s major:%d minor:%d zone:%d sig:%d snap_len:%d type:%d" % (
            ByteOrder.order, self._major_2B, self._minor_2B, self._thisZone_4B, self._sigFigs_4B,self._snapLen_4B,
            self._linkType_4B)

    @staticmethod
    def signature(data):
        """验证签名同时确定排序,虽然此时还未读取到后续大小端"""
        sig = ByteOrder.bytes2int(data)
        if sig == 0xa1b2c3d4:
            ByteOrder.order = "big"
            return True
        elif sig == 0xd4c3b2a1:
            ByteOrder.order = "little"
            return True
        return False


class Packet(object):
    _packetHead_16B = None
    _etherHead_14B = None
    _packet_data = None
    _IPHead = None
    _transportHead = None

    def __init__(self,datas):
        print("  Packet Initing")
        self._packet_data = datas
        self._packetHead_16B = PacketHead(self._packet_data[0:16])
        self._packet_data = self._packet_data[16:]
        self._etherHead_14B = EtherHead(self._packet_data[0:14])
        self._packet_data = self._packet_data[14:]
        self._IPHead = IPHead(self._packet_data)
        self._packet_data = self._packet_data[self.get_ip_head().get_ip_len():]
        if self.get_ip_head().get_protocol() == 17:
            self._transportHead = UDPHead(self._packet_data[0:8])
            self._packet_data = self._packet_data[8:]

    def get_packet_head(self):
        return self._packetHead_16B

    def get_ether_head(self):
        return self._packetHead_16B

    def get_ip_head(self):
        return self._IPHead


class PacketHead(object):
    _secondTime_4B = None
    _millsecondTime_4B = None
    _captureLen_4B = None
    _realLen_4B = None

    def __init__(self,datas):
        print("    PacketHead Initing")
        self._secondTime_4B =ByteOrder.bytes2int(datas[0:4])
        self._millsecondTime_4B = ByteOrder.bytes2int(datas[4:8])
        self._captureLen_4B = ByteOrder.bytes2int(datas[8:12])
        self._realLen_4B = ByteOrder.bytes2int(datas[12:16])
        #print(self.__str__())

    def __str__(self):
        return "    second:%d millsecond:%d caplen:%d reallen %d" % (self._secondTime_4B,self._millsecondTime_4B,self._captureLen_4B,
                                                                self._realLen_4B)

    def get_real_len(self):
        return self._realLen_4B


class EtherHead(object):
    _dst_mac_6B = None
    _src_mac_6B = None
    _type_2B = None

    def __init__(self,datas):
        print("    Ether Initing")
        self._dst_mac_6B = int.from_bytes(datas[0:6],"big")
        self._src_mac_6B = int.from_bytes(datas[6:12],"big")
        self._type_2B = int.from_bytes(datas[12:14],"big")
        #if hex(self._type_2B) == "0x800":
        #   print("IPv4")
        #print(self.__str__())

    def __str__(self):
        return"    mac_src:%012x mac_dst:%012x type:%04x" % (self._src_mac_6B, self._dst_mac_6B, self._type_2B)


class IPHead(object):
    #b是位，B是字节，4b也即是半字节
    _IP_version_4b = None
    _IP_len_4b = None
    _DS_1B = None
    _total_len_2B = None
    _identification_2B = None
    _flag_3b = None
    _deviation_13b = None
    _TTL_1B = None
    _protocol_1B = None
    _check_sum_2B = None
    _srcIp_4B = None
    _dstIp_4B = None

    def __init__(self,datas):
        print("    IPHead Initing")
        self._IP_version_4b = ByteTool.disassembleBytes(datas[0:1], 0, 3)
        self._IP_len_4b = ByteTool.disassembleBytes(datas[0:1], 4, 7) * 4
        self._DS_1B = int.from_bytes(datas[1:2], "big")
        self._total_len_2B = int.from_bytes(datas[2:4], "big")
        self._identification_2B = int.from_bytes(datas[4:6], "big")
        self._flag_3b = ByteTool.disassembleBytes(datas[6:8], 0, 2)
        self._deviation_13b = ByteTool.disassembleBytes(datas[6:8], 3, 15)
        self._TTL_1B = int.from_bytes(datas[8:9], "big")
        self._protocol_1B = int.from_bytes(datas[9:10], "big")
        self._check_sum_2B = int.from_bytes(datas[10:12], "big")
        self._srcIp_4B = int.from_bytes(datas[12:16], "big")
        self._dstIp_4B = int.from_bytes(datas[16:19], "big")
        #print(self.__str__())

    def __str__(self):
        return "    version:%d len:%d DS:%d total_len:%d identi:%d flag:%01x deviation:%d TTL:%d protocol:%d " \
               "check_sum:%04x srcIP:%08x dstIP:%08x" % (self._IP_version_4b, self._IP_len_4b, self._DS_1B, self._total_len_2B,
                                          self._identification_2B, self._flag_3b, self._deviation_13b, self._TTL_1B,
                                          self._protocol_1B, self._check_sum_2B, self._srcIp_4B, self._dstIp_4B)

    def get_ip_len(self):
        return self._IP_len_4b

    def get_protocol(self):
        return self._protocol_1B


class UDPHead(object):
    _src_port_2B = None
    _dst_port_2B = None
    _UDP_len_2B = None
    _check_sum_2B = None

    def __init__(self,datas):
        print("    UDP Initing")
        self._src_port_2B = int.from_bytes(datas[0:2], "big")
        self._dst_port_2B = int.from_bytes(datas[2:4], "big")
        self._UDP_len_2B = int.from_bytes(datas[4:6], "big")
        self._check_sum_2B = int.from_bytes(datas[6:8], "big")
        #print(self.__str__())

    def __str__(self):
        return"    srcPort:%d dstPort:%d UDPLen:%d checkSum:%04x" % (self._src_port_2B, self._dst_port_2B,
                                                                   self._UDP_len_2B, self._check_sum_2B)


if __name__ == '__main__':
    bytes = load_pcap("test22.pcap")
    my_pcap_file = PcapFile(bytes)
