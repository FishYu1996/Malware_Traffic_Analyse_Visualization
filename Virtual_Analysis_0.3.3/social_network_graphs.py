# coding=UTF-8
import networkx as nx
import matplotlib.pyplot as plt
import math
import re as re
from matplotlib.patches import FancyArrowPatch, Circle
import numpy as np
import matplotlib.patches as mpatches
import db_helper
import statistic_analysis


class GraphSql(object):

    def __init__(self):
        self._sql = ""

    def create_db(self):
        self._sql = "social_network_ip_links"
        db_helper.create_table(self._sql)

    def clear_db(self):
        db_helper.clear_table("social_network_ip_links")

    def write_db(self):
        ip_connect_dict = statistic_analysis.get_ip_connect_dict()
        ip_connect_list = []
        for key in ip_connect_dict:
            connect_list = [0]
            temp_key = list(key)
            connect_list += temp_key
            connect_list += [ip_connect_dict[key]]
            connect_tuple = tuple(connect_list)
            ip_connect_list.append(connect_tuple)
        print("准备提交IP连接数据")
        self._sql = "INSERT INTO social_network_ip_links (Id, Src_IP, Dst_IP, Number) VALUES (%d,%s,%s,%d)"
        db_helper.insert_batch(self._sql, ip_connect_list)


class Graph(object):
    def __init__(self):
        self.G = nx.Graph()

    def create_undirect_whole_graph(self):
        sql = "select * from social_network_ip_links"
        results = db_helper.get_data(sql)
        print(results)
        i = 0
        for r in results:
            self.G.add_edge(r[1], r[2], weight=r[3])
            i = i + 1

    def draw_all(self):
        weight = []
        #得到G图边列表[(IP1,IP2,weight)...]
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.G.edges(data=True)]
        #将边权重按顺序加入weight列表.需要注意的是,在生成G图时给边的权重和之后生成png时所画出的边的粗细权重是不同的东西,之后会提到
        for edgelist in edgelists:
            row_weight = edgelist[2]                      #取原始数据权重
            weight.append(math.sqrt(row_weight / 10) + 1) #计算绘画粗细的权重
        color = "blue"            #根据IP性质决定点的颜色,返回颜色列表
        pos = nx.spring_layout(self.G, k=2)               #layout决定点的位置,k决定散布距离
        nx.draw_networkx_nodes(self.G, pos, node_size=100, node_color=color)  #画点,确定点位置,点大小,点颜色
        nx.draw_networkx_edges(self.G, pos, edgelists, width=weight)
        #画边,输入边列表,边粗细权重.两个列表必须顺序对应,否则会权重不匹配
        nx.draw_networkx_labels(self.G, pos, font_size=5, font_family='sans-serif') #打标签
        nodes = list(self.G.nodes)      #取G图的点列表
        self.J = self.G.copy()          #复制一份副本至J,便于统一操作分析
        # visualize(G)                  #本来是用于通过web动态生成可拖拽的图,由于兼容性问题,搁置
        plt.axis('off')                 #关闭网格
        plt.savefig("test.png")         #存图
        plt.clf()                       #清空plt,存完图一定要清,不然会重叠.整个作图逻辑是:nx生成图结构,plt作图.两者都应该及时清空,否则会重叠
        return nodes                    #返回节点列表

if __name__ == '__main__':
    Social_network = GraphSql()
    Social_network.create_db()
    Social_network.clear_db()
    Social_network.write_db()
    Graph = Graph()
    Graph.create_undirect_whole_graph()
    Graph.draw_all()