# coding=UTF-8
import networkx as nx
import matplotlib.pyplot as plt
import MySQLdb
import math
import sys
import MySQLdb
import Analyser
G = nx.Graph()
H=  nx.Graph()
J=  nx.Graph()
weight=[]
def draw():                                      #建立一个空的无向图G
    global G,sql,J
    sql="select * from Link"
    results=Analyser.get_data(sql)
    i=0
    for r in results:
        weight.append(math.sqrt(r[3]/10)+1)
        G.add_edge(r[1],r[2],weight=r[3])
        i=i+1

    sublist=list(nx.connected_components(G))
    H=G.subgraph(list(sublist[0]))
    pos = nx.spring_layout(H, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(H, pos, node_size=200)
    nx.draw_networkx_edges(H, pos, width=weight)
    nx.draw_networkx_labels(H, pos, font_size=5, font_family='sans-serif')
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()

    nodes=[]
    sub_number=0
    while sub_number < sublist.__len__():
        H = G.subgraph(list(sublist[sub_number]))
        J=H.copy()
        IPs=list(degree(0))
        sub_number+=1
        nodes.append(IPs[0])
    return nodes

def draw_SingleIP(IP):
    global sql,J
    J.clear()
    sql="select * from Link where IP1='"+ IP +"'or IP2='"+IP+"'"
    results = Analyser.get_data(sql)
    i = 0
    weight = []
    for r in results:
        weight.append(math.sqrt(r[3] / 10) + 1)
        J.add_edge(r[1], r[2], weight=r[3])
        i = i + 1
    pos = nx.spring_layout(J, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(J, pos, node_size=200)
    nx.draw_networkx_edges(J, pos, width=weight)
    nx.draw_networkx_labels(J, pos, font_size=5, font_family='sans-serif')
    nodes=list(J.nodes)
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    return nodes

def degree(mode):
    if mode ==0:
        degree_saves=nx.degree(J)
        order_degree_rank=sorted(degree_saves,key=lambda x:x[1],reverse=True)
        return order_degree_rank
    elif mode==1:
        degree_saves = nx.degree(H)
        order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
        return order_degree_rank

def betweeness(mode):
    if mode==0 :
        betweeness_saves = nx.betweenness_centrality(J)
        order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
        return order_betweeness_rank
    elif mode==1:
        betweeness_saves = nx.betweenness_centrality(H)
        order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
        return order_betweeness_rank

def degree_centrality(mode):
    if(mode==0):
        degree_centrality_saves = nx.degree_centrality(J)
        order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
        return order_degree_centrality_rank
    elif (mode == 1):
        degree_centrality_saves = nx.degree_centrality(H)
        order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
        return order_degree_centrality_rank

def change_subgraph(id):
    sublist = list(nx.connected_components(G))
    global H,J
    H = G.subgraph(list(sublist[id]))
    pos = nx.spring_layout(H, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(H, pos, node_size=200)
    nx.draw_networkx_edges(H, pos, width=weight)
    nx.draw_networkx_labels(H, pos, font_size=5, font_family='sans-serif')
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    J=H.copy()

def transfer_nodes():
    return list(J.nodes)

def transfer_subnodes():
    return list(H.nodes)



