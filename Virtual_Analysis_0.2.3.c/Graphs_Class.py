# coding=UTF-8
import networkx as nx
import matplotlib.pyplot as plt
import math
import re as re
from matplotlib.patches import FancyArrowPatch, Circle
import numpy as np
import matplotlib.patches as mpatches
import Analyser
import instrument

#图处理类
'''
由于图数据结构依赖于nx,同名的变量会被覆盖,因此GUI类使用时不得不保留本地副本用于确保图的唯一性,本类的G,H,J,L,可以视为通用的图,存在
被覆盖的可能性.
'''
class Graphs():
    G = nx.Graph()  # 总图
    H = nx.Graph()  # 连通子图
    J = nx.Graph()  # 无向图
    L = nx.MultiDiGraph()  # 重图
    abnormal_IP_list = []  #异常IP列表

    #由于G运行一次只有一个,因此不初始化
    def __init__(self,ID):
        self.H.clear()
        self.J.clear()
        self.L.clear()
        print('Initing...'+ str(ID) )


    #生成全图G
    def create_wholeGraph(self):
        sql = "select * from Link"
        results = Analyser.get_data(sql)
        i = 0
        for r in results:
            self.G.add_edge(r[1], r[2], weight=r[3])
            i = i + 1


    #子图划分函数-未完工
    def list_subGraph(self):
        # 取出连通子图列表
        sublist = list(nx.connected_components(self.G))
        nodes = []
        sub_number = 0   #子图ID
        while sub_number < sublist.__len__():
            self.H = self.G.subgraph(list(sublist[sub_number]))  #取对应子图
            self.J = self.H.copy()   #深拷贝一份
            IPs = list(self.degree(0))
            sub_number += 1
            nodes.append(IPs[0])
        return nodes


    #生成全图G的png文件,使用前需要先生成全图G
    def draw_all(self):
        weight = []
        #得到G图边列表[(IP1,IP2,weight)...]
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.G.edges(data=True)]
        #将边权重按顺序加入weight列表.需要注意的是,在生成G图时给边的权重和之后生成png时所画出的边的粗细权重是不同的东西,之后会提到
        for edgelist in edgelists:
            row_weight = edgelist[2]                      #取原始数据权重
            weight.append(math.sqrt(row_weight / 10) + 1) #计算绘画粗细的权重
        color = self.decide_node_color(self.G)            #根据IP性质决定点的颜色,返回颜色列表
        pos = nx.spring_layout(self.G, k=2)               #layout决定点的位置,k决定散布距离
        nx.draw_networkx_nodes(self.G, pos, node_size=100, node_color=color)  #画点,确定点位置,点大小,点颜色
        nx.draw_networkx_edges(self.G, pos, edgelists, width=weight)
        #画边,输入边列表,边粗细权重.两个列表必须顺序对应,否则会权重不匹配
        nx.draw_networkx_labels(self.G, pos, font_size=5, font_family='sans-serif') #打标签
        nodes = list(self.G.nodes)      #取G图的点列表
        self.J = self.G.copy()          #复制一份副本至J,便于统一操作分析
        # visualize(G)                  #本来是用于通过web动态生成可拖拽的图,由于兼容性问题,搁置
        plt.axis('off')                 #关闭网格
        plt.savefig("test.png")         #存图
        plt.clf()                       #清空plt,存完图一定要清,不然会重叠.整个作图逻辑是:nx生成图结构,plt作图.两者都应该及时清空,否则会重叠
        return nodes                    #返回节点列表


    #画单点分析图入口,输入IP
    def draw_SingleIP(self,IP):
        global abnormal_IP_list   #需要异常IP列表来判断使用不同的图J或L
        abnormal_IP_list = Analyser.read_abnormal_IP_list()  #从Analyser读异常IP列表
        if not IP in abnormal_IP_list:
            nodes = self.draw_normal_SingleIP(IP)  #画正常IP
        elif IP in abnormal_IP_list:
            nodes = self.draw_abnormal_SingleIP(IP)#画异常IP
        return nodes                               #返回节点列表


    #画正常单点图
    def draw_normal_SingleIP(self,IP):
        self.J.clear()
        sql = "select * from Link where IP1='" + IP + "'or IP2='" + IP + "'"
        results = Analyser.get_data(sql)
        i = 0
        weight = []
        for r in results:
            self.J.add_edge(r[1], r[2], weight=r[3])
            i = i + 1
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.J.edges(data=True)]
        for edgelist in edgelists:
            row_weight = edgelist[2]
            weight.append(math.sqrt(row_weight / 10) + 1)
        color = self.decide_node_color(self.J)
        pos = nx.spring_layout(self.J, k=1)
        nx.draw_networkx_nodes(self.J, pos, node_size=100, node_color=color)
        nx.draw_networkx_edges(self.J, pos, edgelists, width=weight)
        nx.draw_networkx_labels(self.J, pos, font_size=5, font_family='sans-serif')
        nodes = list(self.J.nodes)
        plt.axis('off')
        # plt.show()
        plt.savefig("test.png")
        plt.clf()
        return nodes


    #画异常单点图
    def draw_abnormal_SingleIP(self,IP):
        # to-do
        self.L.clear()
        self.J.clear()
        abnormal_IPs_detail_dict = instrument.create_abnormal_IPs_dict(self,abnormal_IP_list)  #生成异常IP字典,应该可以从GUI里直接读取
        sql = "select * from Link where IP1='" + IP + "'or IP2='" + IP + "'"
        results = Analyser.get_data(sql)
        for r in results:
            self.J.add_edge(r[1], r[2], sty=5, width=1)    #异常单点图依然需要在J图中生成一份,因为计算三大指标的时候需要使用到J
            if r[1] in abnormal_IP_list and r[2] in abnormal_IP_list:
            #如果两个点都是异常点,则要在重图中详细画出通信中每个特征流量
                role = abnormal_IPs_detail_dict[r[1]]['flawedAmy']  #取r[1]在Amy中充当的角色(服务器或被感染者)
                Amy_Attribution_dict = Analyser.Necurs_flaw_Amy_Attribution(r[1], role) #Amy各特征流量的具体大小,返回为字典
                Amy_Attribution_list = ['download_batch_1', 'download_batch_2', 'download_prefile', 'download_file'] #Amy各特征名字
                label = 1  #用于给边打标记,使之画出多条边
                for Amy_Attribution in Amy_Attribution_list:
                    int_packet_length = int(Amy_Attribution_dict[Amy_Attribution])#取特征名字对应的流量大小
                    if int_packet_length != 0:  #如果存在,由于是有向图，需要根据源和目的地址画边
                        if role == 'C&C Server':
                            self.L.add_edge(r[1], r[2], sty=label, width=1)
                        elif role == 'Infected':
                            self.L.add_edge(r[2], r[1], sty=label, width=1)
                    label += 1   #标记自加
            elif not (r[1] in abnormal_IP_list and r[2] in abnormal_IP_list): #可以直接用else,如果有至少一个点为正常IP
                self.L.add_edge(r[1], r[2], sty=5, width=1)  #只画一条线,style是5
        pos = nx.spring_layout(self.L, threshold=0.2)        #参数我也不知道它是干嘛的,反正这个看起来最好
        ax = plt.gca()   #不知道这是啥
        self.draw_MultipleLine(self.L, pos, ax)  #画重图,具体不知道他是啥
        ax.autoscale()
        #设置标签,考虑单写一个函数,加入接口来调整label和数量
        color_example = []
        red_patch = mpatches.Patch(color='red', label='DNS')
        color_example.append(red_patch)
        blue_patch = mpatches.Patch(color='blue', label='HTTP')
        color_example.append(blue_patch)
        black_patch = mpatches.Patch(color='black', label='HTTPS')
        color_example.append(black_patch)
        yellow_patch = mpatches.Patch(color='yellow', label='TCP')
        color_example.append(yellow_patch)
        green_patch = mpatches.Patch(color='green', label='UDP')
        color_example.append(green_patch)
        plt.legend(handles=color_example)

        nx.draw_networkx_labels(self.L, pos, font_size=5, font_family='sans-serif')  #添加标签
        nodes = list(self.L.nodes)
        plt.axis('equal')
        plt.axis('off')
        plt.savefig("test.png")
        plt.clf()
        plt.close('all')
        return nodes


    # 输入模式,区别使用G,H,J，返回元组列表:[(IP,值),...]
    def degree(self,mode):
        if mode == 0:
            degree_saves = nx.degree(self.G)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank
        elif mode == 1:
            degree_saves = nx.degree(self.H)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank
        elif mode == 2:
            degree_saves = nx.degree(self.J)
            order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
            return order_degree_rank


    def betweeness(self,mode):
        if mode == 0:
            betweeness_saves = nx.betweenness_centrality(self.G)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank
        elif mode == 1:
            betweeness_saves = nx.betweenness_centrality(self.H)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank
        elif mode == 2:
            betweeness_saves = nx.betweenness_centrality(self.J)
            order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
            return order_betweeness_rank


    def degree_centrality(self,mode):
        if (mode == 0):
            degree_centrality_saves = nx.degree_centrality(self.G)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank
        elif (mode == 1):
            degree_centrality_saves = nx.degree_centrality(self.H)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank
        elif (mode == 2):
            degree_centrality_saves = nx.degree_centrality(self.J)
            order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
            return order_degree_centrality_rank


    #未用,用于切换H图,输入为子图id
    def change_subgraph(self,id):
        sublist = list(nx.connected_components(self.G))
        weight = []
        self.H = self.G.subgraph(list(sublist[id]))
        edgelists = [(u, v, d['weight']) for (u, v, d) in self.H.edges(data=True)]
        for edgelist in edgelists:
            row_weight = edgelist[2]
            weight.append(math.sqrt(row_weight / 10) + 1)
        color = self.decide_node_color(self.H)
        pos = nx.spring_layout(self.H, k=1)
        nx.draw_networkx_nodes(self.H, pos, node_size=200, node_color=color)
        nx.draw_networkx_edges(self.H, pos, width=weight)
        nx.draw_networkx_labels(self.H, pos, font_size=5, font_family='sans-serif')
        plt.axis('off')
        plt.savefig("test.png")
        plt.clf()
        self.J = self.H.copy()


    #取G的点
    def transfer_all_nodes(self):
        return list(self.G.nodes)


    #取J的点
    def transfer_nodes(self):
        return list(self.J.nodes)


    # 取H的点
    def transfer_subnodes(self):
        return list(self.H.nodes)


    #画两点的边,目前未用,使用重图
    def draw_Line(self,IP1, IP2):
        i = 0
        #利用i分别画两个方向的边
        while i < 2:
            if i == 0:
                srcIP = IP1
                dstIP = IP2
            elif i == 1:
                srcIP = IP2
                dstIP = IP1
            protocols = Analyser.Link_Protocol_Analyse(srcIP, dstIP, 1)   #返回各种协议及其数据,格式为字符串.参数1或0决定分析模式是否区分方向,1表示有视方向
            protocol_label = 1  #标记
            for protocol in protocols:
                string = str(protocol)
                inform = re.split(r"/|", string)       #正则分割
                int_protocol_proper = int(inform[0])   #得到协议的包数
                if int_protocol_proper != 0:
                    self.L.add_edge(srcIP, dstIP, sty=protocol_label, width=(math.sqrt(int_protocol_proper)) / 3)
                protocol_label += 1
            i += 1
        pos = nx.spring_layout(self.L)
        ax = plt.gca()
        self.draw_MultipleLine(self.L, pos, ax)
        ax.autoscale()

        color_example = []
        red_patch = mpatches.Patch(color='red', label='DNS')
        color_example.append(red_patch)
        blue_patch = mpatches.Patch(color='blue', label='HTTP')
        color_example.append(blue_patch)
        black_patch = mpatches.Patch(color='black', label='HTTPS')
        color_example.append(black_patch)
        yellow_patch = mpatches.Patch(color='yellow', label='TCP')
        color_example.append(yellow_patch)
        green_patch = mpatches.Patch(color='green', label='UDP')
        color_example.append(green_patch)
        plt.legend(handles=color_example)

        nx.draw_networkx_labels(self.L, pos, font_size=5, font_family='sans-serif')
        self.L.clear()
        plt.axis('equal')
        plt.axis('off')
        plt.savefig("Line.png")
        plt.clf()
        plt.close('all')


    #重图绘图,nx本身不支持重图的绘画,需要以下函数补充，但他具体是怎么操作的,完全不明白,送重图L进去就结了
    def draw_MultipleLine(self,L, pos, ax, sg=None):
        for n in L:
            c = Circle(pos[n], radius=0.05, alpha=0.7)
            ax.add_patch(c)
            L.node[n]['patch'] = c
            x, y = pos[n]
        seen = {}
        for (u, v, d) in L.edges(data=True):
            n1 = L.node[u]['patch']
            n2 = L.node[v]['patch']
            rad = 0.1 * 3
            if (u, v) in seen:
                rad = seen.get((u, v))
                rad = (rad + np.sign(rad) * 0.1) * -1
            alpha = 0.5
            style = d['sty']
            if style == 1:
                color = 'r'
            elif style == 2:
                color = 'b'
            elif style == 3:
                color = 'k'
            elif style == 4:
                color = 'y'
            elif style == 5:
                color = 'g'

            width = d['width']
            line = width
            e = FancyArrowPatch(n1.center, n2.center, patchA=n1, patchB=n2,
                                arrowstyle='-|>',
                                connectionstyle='arc3,rad=%s' % rad,
                                mutation_scale=10.0,
                                lw=2,
                                alpha=alpha,
                                color=color)
            e.set_linewidth(line)
            e.set_label(line)
            seen[(u, v)] = rad
            ax.add_patch(e)
        return e


    #根据IP状态决定颜色,输入图,输出颜色列表,一定注意IP和颜色列表的顺序匹配
    def decide_node_color(self,J):
        flag = 0
        global abnormal_IP_list
        abnormal_IP_list = Analyser.read_abnormal_IP_list()
        color = []
        for node in J.nodes: #从图中取点遍历,将其与异常IP列表一一比对,来确定其颜色
            for abnormal_IP in abnormal_IP_list:
                IP = abnormal_IP  #不知道这个干嘛的,冗余代码
                if node == IP:
                    color.append('r')
                    flag = 1    #用来标记正在检查的IP是否属于异常IP
                    break
            if flag != 1:
                color.append('b')
            else:
                flag = 0
        return color


    #返回G图,测试用
    def test_transfer_Graph(self):
        return self.G


