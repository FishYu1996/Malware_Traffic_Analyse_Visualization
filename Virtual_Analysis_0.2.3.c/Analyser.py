# coding=UTF-8
import MySQLdb
import operator
import LSTM_dga
import re as re
abnormal_dict={}   #这个字典记录异常IP及对应的可疑度

#分析类方法,但其中包括数据库的基本方法,讲道理是要另开文件比较简洁,但是懒得了

#查询数据
def get_data(sql):
    conn = MySQLdb.connect("localhost", "root", "root", "Test")
    cursor = conn.cursor()
    # 查询test表中id为11的记录，并将记录数目返回给count
    cursor.execute(sql)
    # 重置游标位置，0,为偏移量，mode＝absolute | relative,默认为relative,
    if(cursor.rowcount!=0):
        cursor.scroll(0, mode='absolute')
        results = cursor.fetchall()
    else:
        results=()
    conn.close()
    return results


#插入数据
def insert_data(sql):
    conn = MySQLdb.connect("localhost", "root", "root", "test")
    cursor = conn.cursor()
    cursor.execute(sql)
    cursor.close()
    conn.commit()
    conn.close()


#清空指定表
def clear_table(table):
    conn = MySQLdb.connect("localhost", "root", "root", "test")
    cursor = conn.cursor()
    sql="truncate "+table
    cursor.execute(sql)


#返回指定表最后一项的id,用于写入数据库时自增id - 事实上主键可以自增,但是既然已经写了这个了,就不折腾主键自增的设置了.
def find_last_id(table):
    sql = "select id from `"+table+"` order by id desc LIMIT 1"
    results = get_data(sql)
    if not results:
        id = 1
    else:
        for result in results:
            id = result[0] + 1
            break
    return id


#针对点的小包分析函数,阈值需要在函数内手动设置,输入IP列表
def Node_Length_Analyse(nodes):
    max=200
    min=0
    all=0
    sum=0
    propdic={}
    for node in nodes:
        sql="SELECT length FROM `data` where srcIp='"+node+"'or dscIp='"+node+"'"
        results=get_data(sql)
        for result in results:
            all+=1
            if result[0]>min and result[0]<max:
                sum+=1
        prop=float(sum)/all
        propdic[node]=prop
        sum=0
        all=0
        ordered_prop_list = sorted(propdic.items(), key=lambda x: x[1], reverse=True)
    return ordered_prop_list


#针对点的连接数分析函数
def Node_Links_Analyse(nodes):
    Links={}
    for node in nodes:
        sql="SELECT sum(count) FROM `link` where IP1='"+node+"'OR IP2='"+node+"'"
        results=get_data(sql)
        for result in results:
            Links[node]=result[0]
        ordered_Links = sorted(Links.items(), key=lambda x: x[1], reverse=True)
    return ordered_Links


#这个函数返回所有点之间的连接关系，强调关系
def All_Link_Analyse():
    sql = "SELECT * FROM `link`"
    results = get_data(sql)
    Links=[]
    for result in results:
        IP1=result[1]
        IP2=result[2]
        Link=(IP1,IP2)
        Links.append(Link)
    return Links


#这个函数也返回所有点之间的连接关系，强调连接数
def Link_Connections():
    sql = "SELECT * FROM `link`"
    results = get_data(sql)
    Links = {}
    for result in results:
        IP1 = result[1]
        IP2 = result[2]
        connection=result[3]
        str=IP1+"->"+IP2
        Links[str]=connection
        ordered_Links = sorted(Links.items(), key=lambda x: x[1], reverse=True)
    return ordered_Links


#返回指定IP对(边)的连接数
def Link_Connection(IP1,IP2):
    sql = "SELECT count FROM `link` where (IP1='" + IP1 + "'and IP2='"+IP2+"')or(IP1='"+IP2+"'and IP2='"+IP1+"')"
    results = get_data(sql)
    count=0
    for result in results:
        count=result[0]
        break
    return count


#返回指定IP对(边)的包大小-返回字符串列表,包括小包占比和大包占比,阈值手动调整
def Link_Length_Analyse(IP1,IP2):
    i=0
    String=[]
    sql="SELECT length FROM `data`  where (srcIp='" + IP1 + "'and dscIp='"+IP2+"')or(srcIp='"+IP2+"'and dscIp='"+IP1+"')"
    results=get_data(sql)
    max=200
    min=0
    while i<2:
        count = 0
        sum = 0
        for result in results:
            if result[0]>min and result[0]<max:
                count+=1
            sum+=1
        prop=round(float(count)/sum,5)
        String.append(str(count)+"/"+str(prop))
        max = 1500
        min = 1000
        i+=1
    return String


#返回指定IP对(边)的协议构成-返回字符串列表,mode参数控制是否考虑方向
def Link_Protocol_Analyse(IP1,IP2,mode=0):
    String = []
    DNS = 0
    HTTP = 0
    HTTPS = 0
    TCP = 0
    UDP = 0
    sum = 0
    if mode == 0:
        sql = "SELECT protocol,appProto FROM `data`  where (srcIp='" + IP1 + "'and dscIp='" + IP2 + "')or(srcIp='" + IP2 + "'and dscIp='" + IP1 + "')"
    if mode == 1:
        sql = "SELECT protocol,appProto FROM `data`  where (srcIp='" + IP1 + "'and dscIp='" + IP2 + "')"
    results = get_data(sql)
    for result in results:
        sum+=1
        if operator.eq(result[1],"null")==True:
            if result[0]==17:
                UDP+=1
            elif result[0]==6:
                TCP+=1
        else:
            if operator.eq(result[1],"HTTP")==True:
                HTTP+=1
                continue
            if operator.eq(result[1],"HTTPS") == True:
                HTTPS += 1
                continue
            if operator.eq(result[1],"DNS") == True:
                DNS += 1
                continue
    if sum == 0:
        sum = 1
    prop = round(float(DNS) / sum, 5)
    String.append(str(DNS) + "/" + str(prop))
    prop = round(float(HTTP) / sum, 5)
    String.append(str(HTTP) + "/" + str(prop))
    prop = round(float(HTTPS) / sum, 5)
    String.append(str(HTTPS) + "/" + str(prop))
    prop = round(float(TCP) / sum, 5)
    String.append(str(TCP) + "/" + str(prop))
    prop = round(float(UDP) / sum, 5)
    String.append(str(UDP) + "/" + str(prop))
    return String


#返回所有端口和协议不匹配的IP列表,计划移除
def Wrong_Matched_Port():
    IPs={}
    sql="select srcIp,dscIp from `data` where srcPort=80 AND appProto='null'"
    count=0
    results=get_data(sql)
    for result in results:
        str=result[0]+"->"+result[1]+"     HTTP-80"
        if str in IPs:
            count=IPs[str]
            IPs[str]=count+1
        else:
            count=1
            IPs[str]=count
    IPs = sorted(IPs.items(), key=lambda x: x[1], reverse=True)
    return IPs


#特殊的DNS+HTTP的通信模式,计划移除
def DNS_HTTP_Mode():
    DH_Mode=[]
    sql = "select * from `data` where appProto='DNS' and  appInform4 is not null "
    results = get_data(sql)
    if  results:
        for result in results:
            DNS_Server=result[3]
            Queryer=result[4]
            Answer=result[13]
            DH_Single=[]
            DH_Single.append(Queryer)
            DH_Single.append(result[3])
            DH_Single.append(Answer)
            sql = "select * from `data` where appProto='HTTP' and  srcIp='"+Queryer+"'and dscIp='"+Answer+"'"
            results = get_data(sql)
            if results:
                sql = "select count from `link` where (IP1='" + Queryer + "'and IP2='" + Answer + \
                      "')or(IP1='"+Answer+"'and IP2='"+Queryer+"')"
                results = get_data(sql)
                DH_Single.append(results[0][0])
                DH_Mode.append(DH_Single)
            else:
                print("null")
    else:
        print("null")
    IP_Links={}
    for DH_Single in DH_Mode:
        str=DH_Single[0]+"->"+DH_Single[1]+"->"+DH_Single[2]
        IP_Links[str] = DH_Single[3]
    IP_Links = sorted(IP_Links.items(), key=lambda x: x[1], reverse=True)
    return IP_Links


#预测流量中是否存在dga域名,主要从HTTP中HOST携带的域名来检测.dga检测模型由张鑫师兄提供.
def predict_dga():
    #以下先构成需要检测的输入IP列表
    global abnormal_dict
    sql="select dscIp,appInform2 from `data` where appProto='HTTP' and appInform2 !=''"
    results = get_data(sql)
    test_dict={}
    inputlists=[]
    for result in results:
        split_result=result[1].split('.') #对域名正则分割
        if split_result[0] in test_dict:#取主要域名(第一部分）,如果已经记录在待测域名字典中了,则跳过,否则记录域名及对应目标IP.形式是字典
            pass
        else:
            test_dict[split_result[0]]=result[0]  #构建待测域名字典（用于最后对照IP)
            inputlists.append(split_result[0])    #构建待测域名列表
    #####
    abnormal_domains=LSTM_dga.predict_dga(inputlists) #送模型预测,返回确认的dga域名
    id=find_last_id("abnormal_list")      #得到指定表末尾的下一个id,准备写数据库
    for abnormal_domain in abnormal_domains:
        abnormal_ip=test_dict[abnormal_domain]  #根据已知dga域名,去字典查对应IP
        flag="YES"                              #dga标志
        sql = "Insert into abnormal_list(id,IP,has_dga) values (" + str(id) + ",'" + abnormal_ip + "','" + flag + "')"
        insert_data(sql)
        #修改异常IP可疑度字典
        if abnormal_ip in abnormal_dict:
            abnormal_dict[abnormal_ip]+=1
        else:
            abnormal_dict[abnormal_ip]=1
        id+=1  #不必每次都用find方法去找末尾值


#如方法名的特殊流量模式:命令行脚本1->下载脚本1->恶意程序组件1(可选)->恶意程序主体
def Necurs_flaw_Amy():
    C2Servers=[]
    InfectedIPs=[]
    sql = "select srcIp,dscIp,appInform3 from `data` where appProto='HTTP' and appInform ='Response'"
    #脚本大小主要从HTTP Response中所携带的数据信息来读取
    results = get_data(sql)
    for result in results:
        stateflag = 0    #用于标记判断器当前状态
        if(int(result[2])>160 and int(result[2])<180):   #检测到疑似命令行脚本,标记分+10
            stateflag+=10
            tempServer = result[0]  #这两个变量用于储存嫌疑流量中的源IP和目的IP 用于之后标记其角色
            tempInfect = result[1]
            sql = "select srcIp,dscIp,appInform3 from `data` where appProto='HTTP' and appInform ='Response'and dscIP='"+ tempInfect +"'"
            #由于脚本并不一定一直通过同一个源IP来发送,因此监控目的IP的接收情况
            results_2 = get_data(sql)
            for result_2 in results_2:
                if (stateflag==10 and int(result_2[2]) > 300 and int(result_2[2]) < 330):#检测到下载脚本
                    stateflag += 10
                elif (stateflag==20 and int(result_2[2]) > 120000 and int(result_2[2]) < 230000):#检测到恶意程序可选组件
                    stateflag+=5    #由于此项非必须项,但又为了今后区别,分数为5,不影响最终判断
                elif (stateflag >= 20 and int(result_2[2]) > 650000 and int(result_2[2]) < 900000):#检测到恶意程序本体
                    stateflag+=10
                if stateflag>=30: #可疑分达到阈值,判定为该模式
                    C2Servers.append(tempServer)   #正式将嫌疑IP分别写入各自角色的IP列表
                    InfectedIPs.append(tempInfect)
    C2Servers=list(set(C2Servers))  #去重复
    InfectedIPs=list(set(InfectedIPs))
    #以下两个for循环均为修改异常IP可疑度字典
    for  C2Server in C2Servers:
        if  C2Server in abnormal_dict:
            abnormal_dict[C2Server]+=1
            sql="update abnormal_list set Necurs_FlawedAmy='C&C Server' where IP='"+C2Server+"'"
            insert_data(sql)
        else:
            abnormal_dict[ C2Server]=1
            id = find_last_id("abnormal_list")
            sql = "Insert into abnormal_list(id,IP,Necurs_FlawedAmy) values (" + str(id) + ",'" +  C2Server + "','C&C Server')"
            insert_data(sql)
    for  InfectedIP in InfectedIPs:
        if  InfectedIP in abnormal_dict:
            abnormal_dict[InfectedIP]+=1
            sql="update abnormal_list set Necurs_FlawedAmy='Infected' where IP='"+C2Server+"'"
            insert_data(sql)
        else:
            abnormal_dict[InfectedIP]=1
            id = find_last_id("abnormal_list")
            sql = "Insert into abnormal_list(id,IP,Necurs_FlawedAmy) values (" + str(id) + ",'" +  InfectedIP + "','Infected')"
            insert_data(sql)


#Amy特殊流量分析的详细判定-返回流量过程中特征部分的具体大小.输入异常IP及其角色,输出流量特征字典
def Necurs_flaw_Amy_Attribution(IP,role):
    #to-do
    Amy_length_attribution={} #流量特征字典
    if role == 'C&C Server':
        sql = "select dscIP,appInform3 from `data` where appProto='HTTP' and appInform ='Response'and srcIP='"+ IP +"'"
    elif role == 'Infected':
        sql = "select dscIP,appInform3 from `data` where appProto='HTTP' and appInform ='Response'and dscIP='" + IP + "'"
    results=get_data(sql)
    #和上一个方法如出一辙,不再注释
    for result in results:
        stateflag = 0
        if (int(result[1]) > 160 and int(result[1]) < 180):
            stateflag += 10
            Amy_length_attribution['download_batch_1']=result[1]
            tempInfect = result[0]
            sql = "select appInform3 from `data` where appProto='HTTP' and appInform ='Response'and dscIP='" + tempInfect +"'"
            results_2 = get_data(sql)
            for result_2 in results_2:
                if (stateflag == 10 and int(result_2[0]) > 300 and int(result_2[0]) < 330):
                    stateflag += 10
                    Amy_length_attribution['download_batch_2'] = result_2[0]
                elif (stateflag == 20 and int(result_2[0]) > 120000 and int(result_2[0]) < 230000):
                    stateflag += 5
                    Amy_length_attribution['download_prefile'] = result_2[0]
                elif (stateflag >= 20 and int(result_2[0]) > 650000 and int(result_2[0]) < 900000):
                    stateflag += 10
                    Amy_length_attribution['download_file'] = result_2[0]
                if stateflag >= 30:
                    break
    #print(Amy_lentth_attribution)
    return Amy_length_attribution


#异常模式分析入口
def abnormal_modes_analyse():
    global abnormal_dict
    abnormal_dict = {}
    clear_table("abnormal_list")   #清空该表,每运行一次程序,都是全新的.
    abnormal_IPs_Ranks=[]          #tuplelist,用于GUI中显示异常IP及其可疑度
    predict_dga()                  #分析dga
    Necurs_flaw_Amy()              #分析Amy
    for key in abnormal_dict:      #构建异常IP及其可疑度的tuple-所以abnormal_dict为啥不用tuple?答：tuple没法修改
        tuple=(key,abnormal_dict[key])
        abnormal_IPs_Ranks.append(tuple)
    order_abnormal_IPs_Ranks = sorted(abnormal_IPs_Ranks, key=lambda x: x[1], reverse=True) #按照可疑度排序
    return order_abnormal_IPs_Ranks


#以下三个read方法不解释
#算了还是解释吧.
#返回异常IP列表(这个不读数据库),目前全部采用下者
def read_abnormal_IPs():
    abnormal_IPs=list(abnormal_dict.keys())
    return abnormal_IPs


#返回异常IP列表(这个读数据库)
def read_abnormal_IP_list():
    sql = "select IP from `abnormal_list`"
    results = get_data(sql)
    list=[]
    for result in results:
        list.append(result[0])
    return(list)


#返回异常IP可疑度字典
def read_abnormal_IP_dict():
    return abnormal_dict


#返回所有与异常IP有关的边及其连接数.返回tuplelist[(IP1,IP2,data)...]
def abnormal_links(IP_list):
    abnormal_links=[]
    for IP in IP_list:
        sql = "select * from `link` where IP1='"+IP+"'or IP2='"+IP+"'"
        results=get_data(sql)
        for result in results:
            abnormal_links_tuple=(result[1],result[2],result[3])
            if abnormal_links_tuple not in abnormal_links:
                abnormal_links.append(abnormal_links_tuple)
    return abnormal_links
