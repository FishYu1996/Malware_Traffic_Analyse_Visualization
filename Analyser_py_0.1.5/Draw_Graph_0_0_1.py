# coding=UTF-8
import networkx as nx
import matplotlib.pyplot as plt
import MySQLdb
import math
import sys
import MySQLdb
import Analyser

G = nx.Graph()
H=  nx.Graph()
J=  nx.Graph()
weight=[]
def draw_all():
    global G, sql,J
    sql = "select * from Link"
    results = Analyser.get_data(sql)
    i = 0
    weight = []
    for r in results:
        G.add_edge(r[1], r[2], weight=r[3])
        i = i + 1
    edgelists = [(u, v,d['weight']) for (u, v, d) in G.edges(data=True)]
    for edgelist in edgelists:
        row_weight=edgelist[2]
        weight.append(math.sqrt(row_weight / 10) + 1)
    pos = nx.spring_layout(G, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(G, pos, node_size=200)
    nx.draw_networkx_edges(G,pos,edgelists,width=weight)
    nx.draw_networkx_labels(G, pos, font_size=5, font_family='sans-serif')
    nodes = list(G.nodes)
    J=G.copy()
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    return nodes

def draw():                                      #建立一个空的无向图G
    global G,sql,J
    sql="select * from Link"
    results=Analyser.get_data(sql)
    i=0
    for r in results:
        G.add_edge(r[1],r[2],weight=r[3])
        i=i+1

    sublist=list(nx.connected_components(G))
    H=G.subgraph(list(sublist[0]))
    edgelists = [(u, v, d['weight']) for (u, v, d) in H.edges(data=True)]
    for edgelist in edgelists:
        row_weight = edgelist[2]
        weight.append(math.sqrt(row_weight / 10) + 1)
    pos = nx.spring_layout(H, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(H, pos, node_size=200)
    nx.draw_networkx_edges(H, pos,edgelists,width=weight)
    nx.draw_networkx_labels(H, pos, font_size=5, font_family='sans-serif')
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()

    nodes=[]
    sub_number=0
    while sub_number < sublist.__len__():
        H = G.subgraph(list(sublist[sub_number]))
        J=H.copy()
        IPs=list(degree(0))
        sub_number+=1
        nodes.append(IPs[0])
    return nodes

def draw_SingleIP(IP):
    global sql,J
    J.clear()
    sql="select * from Link where IP1='"+ IP +"'or IP2='"+IP+"'"
    results = Analyser.get_data(sql)
    i = 0
    weight = []
    for r in results:
        J.add_edge(r[1], r[2], weight=r[3])
        i = i + 1
    edgelists = [(u, v, d['weight']) for (u, v, d) in J.edges(data=True)]
    for edgelist in edgelists:
        row_weight = edgelist[2]
        weight.append(math.sqrt(row_weight / 10) + 1)
    pos = nx.spring_layout(J, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(J, pos, node_size=200)
    nx.draw_networkx_edges(J, pos, edgelists,width=weight)
    nx.draw_networkx_labels(J, pos, font_size=5, font_family='sans-serif')
    nodes=list(J.nodes)
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    return nodes

def degree(mode):
    if mode ==0:
        degree_saves=nx.degree(J)
        order_degree_rank=sorted(degree_saves,key=lambda x:x[1],reverse=True)
        return order_degree_rank
    elif mode==1:
        degree_saves = nx.degree(H)
        order_degree_rank = sorted(degree_saves, key=lambda x: x[1], reverse=True)
        return order_degree_rank

def betweeness(mode):
    if mode==0 :
        betweeness_saves = nx.betweenness_centrality(J)
        order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
        return order_betweeness_rank
    elif mode==1:
        betweeness_saves = nx.betweenness_centrality(H)
        order_betweeness_rank = sorted(betweeness_saves.items(), key=lambda x: x[1], reverse=True)
        return order_betweeness_rank

def degree_centrality(mode):
    if(mode==0):
        degree_centrality_saves = nx.degree_centrality(J)
        order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
        return order_degree_centrality_rank
    elif (mode == 1):
        degree_centrality_saves = nx.degree_centrality(H)
        order_degree_centrality_rank = sorted(degree_centrality_saves.items(), key=lambda x: x[1], reverse=True)
        return order_degree_centrality_rank

def change_subgraph(id):
    sublist = list(nx.connected_components(G))
    global H,J
    H = G.subgraph(list(sublist[id]))
    pos = nx.spring_layout(H, k=1)  # positions for all nodes
    nx.draw_networkx_nodes(H, pos, node_size=200)
    nx.draw_networkx_edges(H, pos, width=weight)
    nx.draw_networkx_labels(H, pos, font_size=5, font_family='sans-serif')
    plt.axis('off')
    plt.savefig("test.png")
    plt.clf()
    J=H.copy()

def transfer_nodes():
    return list(J.nodes)

def transfer_subnodes():
    return list(H.nodes)

def draw_pie(propers):
    plt.figure(figsize=(6, 5))
    protocols = [u'DNS', u'HTTP', u'HTTPS', u'TCP', u'UDP']
    colors = ['red', 'yellow', 'blue', 'green','pink']
    act_protocols=[]
    act_propers=[]
    act_colors=[]
    explode=[]
    counter=0
    for proper in propers:
        proper_float=float(proper)
        if proper_float!=0:
            act_protocols.append(protocols[counter])
            act_propers.append(proper_float)
            act_colors.append(colors[counter])
            explode.append(0.05)
        counter+=1
    act_explode = tuple(explode)

    patches, l_text, p_text = plt.pie(act_propers, explode=act_explode, labels= act_protocols, colors=act_colors,
                                       labeldistance=1.1, autopct='%2.1f%%', shadow=False,
                                       startangle=90, pctdistance=0.8)

    # labeldistance，文本的位置离远点有多远，1.1指1.1倍半径的位置
    # autopct，圆里面的文本格式，%3.1f%%表示小数有三位，整数有一位的浮点数
    # shadow，饼是否有阴影
    # startangle，起始角度，0，表示从0开始逆时针转，为第一块。一般选择从90度开始比较好看
    # pctdistance，百分比的text离圆心的距离
    # patches, l_texts, p_texts，为了得到饼图的返回值，p_texts饼图内部文本的，l_texts饼图外label的文本

    # 改变文本的大小
    # 方法是把每一个text遍历。调用set_size方法设置它的属性
    for t in l_text:
        t.set_size = 30
    for t in p_text:
        t.set_size = 20
        # 设置x，y轴刻度一致，这样饼图才能是圆的
    plt.axis('equal')
    plt.legend(loc='upper left', bbox_to_anchor=(-0.1, 1.1))
    # loc: 表示legend的位置，包括'upper right','upper left','lower right','lower left'等
    # bbox_to_anchor: 表示legend距离图形之间的距离，当出现图形与legend重叠时，可使用bbox_to_anchor进行调整legend的位置
    # 由两个参数决定，第一个参数为legend距离左边的距离，第二个参数为距离下面的距离
    plt.grid()
    plt.savefig("pie.png")
    plt.clf()
    plt.close('all')

