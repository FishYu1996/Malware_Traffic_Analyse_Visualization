# coding=UTF-8
from tkinter import *
from PIL import Image, ImageTk
import Analyser
#import Draw_Graph
import operator
import instrument
from Graphs_Class import Graphs

'''
Date: 2018/11/28
Author:YuJunjie
Describe:This's the class for GUI
'''
GUI_ID = 0 #标记窗口ID，暂无用
abnormal_IPs_list=[] #异常IP列表
abnormal_Links_list=[] #所有与异常IP有关的连接。为元组列表:[(IP1,IP2,连接数),...]
abnormal_IPs_detail_dict={} #所有异常IP的详细字典。为字典的字典:{IP1:{特征:数据,...},IP2:{特征:数据,...}...}

#GUI类
class App():
    load_in_flag = 0 #导入标记，0未导入，1导入
    flag_for_section = 0 #板块标记,0全局分析,1连通图分析,2单点分析,3暂无,4异常点分析
    '''
    # 初始化生成窗口.
    # 参数root判断是主GUI还是子GUI,若为子GUI,传输绝对根.
    # 参数IP传输子GUI要表示的核心IP
    '''
    def __init__(self,root = None,IP = None):
        self.GUI_ID = GUI_ID #获取自身GUI_ID
        self.graphs = Graphs(self.GUI_ID) #生成Graphs类用于完成各种图方法
        #root为空，说明是主GUI
        if root == None:
            #创建根容器
            self.IP = None #主GUI无核心IP
            self.root = Tk() #创建容器
            self.final_root=self.root #将容器作为整个GUI的绝对根
            self.root.title("APP")
            #创建菜单栏
            menu = Menu(self.root)
            self.root.config(menu=menu)# 创建“系统”子菜单
            #第一子菜单栏
            submenu=Menu(menu,tearoff=0)
            submenu.add_command(label="导入",command=self.Load_In)
            submenu.add_separator()
            submenu.add_command(label="退出",command=self.root.quit)
            menu.add_cascade(label="系统",menu=submenu)
            #第二子菜单栏
            submenu=Menu(menu,tearoff=0)
            submenu.add_command(label="总图分析",command=self.All_Analyse)
            menu.add_cascade(label="总图信息",menu=submenu)
            #第三子菜单栏
            submenu = Menu(menu, tearoff=0)
            submenu.add_command(label="连通图")
            menu.add_cascade(label="连通图分析", menu=submenu)
            #第四子菜单栏
            submenu = Menu(menu, tearoff=0)
            submenu.add_command(label="所有异常IP")
            submenu.add_command(label="含dga域名")
            submenu.add_command(label="Necurs_Ammyy模式")
            menu.add_cascade(label="异常模式分析", menu=submenu)
        #root不为空,说明是子GUI
        else :
            self.final_root = root    #绝对根以参数而非生成的形式传输给子GUI,保证子GUI是依附于主GUI存在的
            self.flag_for_section = 2 #子GUI有核心IP,是针对单点分析而产生的，因此取2
            self.load_in_flag = 1     #子GUI无需再导入，直接置1
            self.IP = IP              #记录核心IP
            self.root = Toplevel(root, width=800, height=800) #生成子GUI
            self.root.title(IP)
            self.root.attributes('-topmost', 1)

        #主视图
        self.lb1 = LabelFrame(self.root, width=800, height=950, text='视图')
        self.lb1.grid(row=0, column=0, padx=15,rowspan=2)
        #初始化填充背景
        self.img = Image.open('cover1.png')  # 打开背景图片
        self.photo = ImageTk.PhotoImage(self.img)  # 用PIL模块的PhotoImage打开
        self.Label_Image = Label(self.lb1, width=780, height=900,image=self.photo)
        self.Label_Image.place(x=5,y=0)
        #点信息控制区
        self.lb2= LabelFrame(self.root, width=500, height=460, text='点信息控制')
        self.lb2.grid(row=0, column=1, padx=15)
        self.control_title=Label(self.lb2,text='请选择')
        self.control_title.place(x=130,y=0)
        self.control_tip = Label(self.lb2, text='IP节点                                    点的可疑等级')
        self.control_tip.place(x=60, y=40)
        #点列表
        self.ip_listbox=Listbox(self.lb2,width=50,height=10)
        self.ip_listbox.place(x=10,y=65)
        self.ip_listbox.bind("<<ListboxSelect>>", self.show_msg)
        #按钮们
        self.certain_button = Button(self.lb2,width=10,text="确定",command=self.menu_select)
        self.certain_button.place(x=50,y=300)
        self.return_button = Button(self.lb2,width=10, text="返回",command=self.menu_return)
        self.return_button.place(x=180,y=300)
        #单选框选择排序方式
        self.rad_1 = IntVar()
        self.rad_1.set(0)
        self.Order = ["度","介数中心性","点度中心性","连接数","小包占比","可疑度"]
        for col in range(2):
            for col2 in range(3):
                Order_Rad = Radiobutton(self.lb2, text=self.Order[col*3+col2], variable=self.rad_1, value=col*3+col2,
                            command=self.radCall)
                Order_Rad.place(x=130 * col2+20, y=350+col*50)
        #边信息控制区
        self.lb5 = LabelFrame(self.root, width=500, height=460, text='边信息控制')
        self.lb5.grid(row=1, column=1, padx=15,)
        self.control_title_2 = Label(self.lb5, text='请选择')
        self.control_title_2.place(x=130, y=0)
        self.control_tip_2 = Label(self.lb5, text='边                                 连接数   ')
        self.control_tip_2.place(x=60, y=40)
        #边列表
        self.ip_listbox_2 = Listbox(self.lb5, width=50, height=10)
        self.ip_listbox_2.place(x=10, y=65)
        self.ip_listbox_2.bind("<<ListboxSelect>>", self.show_msg_2)
        #按钮们
        self.certain_button_2 = Button(self.lb5, width=10, text="确定", command=self.menu_select_2)
        self.certain_button_2.place(x=50, y=300)
        self.return_button_2 = Button(self.lb5, width=10, text="返回", command=self.menu_return_2)
        self.return_button_2.place(x=180, y=300)
        #单选框选择边排序方式
        self.Order = ["1", "2", "3", "4", "5", "6"]
        self.rad_2 = IntVar()
        self.rad_2.set(0)
        for col in range(2):
            for col2 in range(3):
                Order_Rad = Radiobutton(self.lb5, text=self.Order[col * 3 + col2], variable=self.rad_2,
                                        value=col * 3 + col2,
                                        command=self.radCall_Line)
                Order_Rad.place(x=130 * col2 + 20, y=350 + col * 50)
        #点信息显示区
        self.lb3 = LabelFrame(self.root, width=400, height=460, text='点信息显示')
        self.lb3.grid(row=0, column=2, padx=15)
        self.inform_text_x=100
        self.inform_Text0 = Label(self.lb3, text="度")
        self.inform_Text0.place(x=self.inform_text_x * 0 + 30, y=0 * 40 +5)
        self.inform_Text1 = Label(self.lb3, text=0)
        self.inform_Text1.place(x=self.inform_text_x * 1 + 30, y=0 * 40 + 5)
        self.inform_Text2 = Label(self.lb3, text="介数中心性")
        self.inform_Text2.place(x=self.inform_text_x * 0 + 30, y=1 * 40 + 5)
        self.inform_Text3 = Label(self.lb3, text=0)
        self.inform_Text3.place(x=self.inform_text_x * 1 + 30, y=1 * 40 + 5)
        self.inform_Text4 = Label(self.lb3, text="点度中心性")
        self.inform_Text4.place(x=self.inform_text_x * 0 + 30, y=2 * 40 + 5)
        self.inform_Text5 = Label(self.lb3, text=0)
        self.inform_Text5.place(x=self.inform_text_x * 1 + 30, y=2 * 40 + 5)
        self.inform_Text6 = Label(self.lb3, text="连接数")
        self.inform_Text6.place(x=self.inform_text_x * 0 + 30, y=3 * 40 + 5)
        self.inform_Text7 = Label(self.lb3, text=0)
        self.inform_Text7.place(x=self.inform_text_x * 1 + 30, y=3 * 40 + 5)
        self.inform_Text8 = Label(self.lb3, text="小包占比")
        self.inform_Text8.place(x=self.inform_text_x * 0 + 30, y=4 * 40 + 5)
        self.inform_Text9 = Label(self.lb3, text=0)
        self.inform_Text9.place(x=self.inform_text_x * 1 + 30, y=4 * 40 + 5)
        self.inform_Text10 = Label(self.lb3, text="dga")
        self.inform_Text10.place(x=self.inform_text_x * 0 + 30, y=5 * 40 + 5)
        self.inform_Text11 = Label(self.lb3, text='No')
        self.inform_Text11.place(x=self.inform_text_x * 1 + 30, y=5 * 40 + 5)
        self.inform_Text12 = Label(self.lb3, text="FlawedAmy")
        self.inform_Text12.place(x=self.inform_text_x * 0 + 30, y=6 * 40 + 5)
        self.inform_Text13 = Label(self.lb3, text='Null')
        self.inform_Text13.place(x=self.inform_text_x * 1 + 30, y=6 * 40 + 5)
        #边信息显示区
        self.lb4 = LabelFrame(self.root, width=400, height=460, text='边信息显示')
        self.lb4.grid(row=1, column=2, padx=15)
        self.spe_inform_text_x = 100
        self.spe_inform_Text0 = Label(self.lb4, text="连接数")
        self.spe_inform_Text0.place(x=self.spe_inform_text_x * 0 + 20, y=0 * 40 + 5)
        self.spe_inform_Text1 = Label(self.lb4, text=0)
        self.spe_inform_Text1.place(x=self.spe_inform_text_x * 1 + 20, y=0 * 40 + 5)
        self.spe_inform_Text2 = Label(self.lb4, text="小包数/占比")
        self.spe_inform_Text2.place(x=self.spe_inform_text_x * 0 + 20, y=1 * 40 + 5)
        self.spe_inform_Text3 = Label(self.lb4, text=0)
        self.spe_inform_Text3.place(x=self.spe_inform_text_x * 1 + 20, y=1 * 40 + 5)
        self.spe_inform_Text4 = Label(self.lb4, text="大包数/占比")
        self.spe_inform_Text4.place(x=self.spe_inform_text_x * 0 + 20, y=2 * 40 + 5)
        self.spe_inform_Text5 = Label(self.lb4, text=0)
        self.spe_inform_Text5.place(x=self.spe_inform_text_x * 1 + 20, y=2 * 40 + 5)
        self.spe_inform_Text6 = Label(self.lb4, text="DNS")
        self.spe_inform_Text6.place(x=self.spe_inform_text_x * 0 + 20, y=3 * 40 + 5)
        self.spe_inform_Text7 = Label(self.lb4, text=0)
        self.spe_inform_Text7.place(x=self.spe_inform_text_x * 1 + 20, y=3 * 40 + 5)
        self.spe_inform_Text8 = Label(self.lb4, text="HTTP")
        self.spe_inform_Text8.place(x=self.spe_inform_text_x * 0 + 20, y=4 * 40 + 5)
        self.spe_inform_Text9 = Label(self.lb4, text=0)
        self.spe_inform_Text9.place(x=self.spe_inform_text_x * 1 + 20, y=4 * 40 + 5)

        #如果为子GUI,为了避免Graphs中图的互相影响，需要先在子GUI中留存A-J,B-L的私有备份
        if self.IP != None:
            self.Single_Analyse(IP)       #根据核心IP展开分析
            self.A = self.graphs.J.copy() #深copy
            self.B = self.graphs.L.copy()
            self.IP_details(self.IP)      #显示核心IP相关信息
            self.flag_for_section = 2     #冗余代码-事实上标志已经置2


    # 所有点分析-基于数据库-存于G图
    def All_Node_Analyse(self):
            if self.load_in_flag == 1:
                self.control_title.config(text="所有节点")
                self.control_tip.config(text='IP节点                                    点的度')
                self.graphs.draw_all()             #生成G图及png图片
                self.Load_img('test.png')          #处理、打开、加载png图片
                self.Rank(self.graphs.degree(0))   #按照'度'将点在上方列表框排序显示,Rank缺省参数0表示上方的列表框.
                                                   # degree参数表示基于不同的图,详见degree函数


    # 所有边分析-基于数据库
    def All_Link_Analyse(self):
            if self.load_in_flag == 1:
                self.control_title_2.config(text="所有边")
                self.control_tip_2.config(text='IP对                                    连接数')
                self.spe_inform_Text0.config(text="连接数")
                self.spe_inform_Text1.config(text="0")
                self.spe_inform_Text2.config(text="小包数/占比")
                self.spe_inform_Text3.config(text="0/0")
                self.spe_inform_Text4.config(text="大包数/占比")
                self.spe_inform_Text5.config(text="0/0")
                self.spe_inform_Text6.config(text="DNS/占比")
                self.spe_inform_Text7.config(text="0/0")
                self.spe_inform_Text8.config(text="HTTP/占比")
                self.spe_inform_Text9.config(text="0/0")
                self.Rank(Analyser.Link_Connections(),1) #统计所有边,及其数量并排序在下方列表框显示


    # 总图分析入口-分别调用点和边分析,并将板块标志置0
    def All_Analyse(self):
        self.All_Node_Analyse()
        self.All_Link_Analyse()
        self.flag_for_section=0


    # 基于单点.从点的角度进行分析,输入参数为核心IP
    def Single_Node_Analyse(self,IP):
        self.control_title.config(text="所有节点")
        self.control_tip.config(text='IP节点                                    点的度')
        self.graphs.draw_SingleIP(IP)     #画单点展开图-存于J图或L图
        self.Load_img('test.png')
        self.Rank(self.graphs.degree(2))

    '''
    # 基于单点,从边的角度进行分析,暂未开工
    def Single_Link_Analyse(self):
        self.Rank(Analyser.Node_Links_Analyse(IPs), 1)
    '''


    #单点分析入口
    def Single_Analyse(self,IP):
        self.Single_Node_Analyse(IP)
        #self.Single_Link_Analyse()


    # 导入数据，显示可疑IP和可疑度
    def Load_In(self):
        #导入过程中需要为异常IP的三个数据结构写入数据
        global abnormal_Links_list
        global abnormal_IPs_list
        global abnormal_IPs_detail_dict
        self.graphs.create_wholeGraph()  #生成G图,但不生成png
        abnormal_IPs_Rank = Analyser.abnormal_modes_analyse()  #执行异常IP判断程序,详见该函数.返回排序后的[(异常IP,异常数)...]
        self.Rank(abnormal_IPs_Rank,0)   #显示至上部列表框
        abnormal_IPs_list=Analyser.read_abnormal_IP_list()  #读取异常IP列表
        abnormal_Links_list=Analyser.abnormal_links(abnormal_IPs_list) #读取异常IP连接列表
        Links_list=instrument.change_IPs_to_Links_str(abnormal_Links_list)  #将异常IP连接列表中的两个IP拼接成字符串.最终返回字符串列表
        data_list=[]   #存异常IP连接列表中的连接数数据,由于其和Links_list均从一个列表中顺序读取,因此是一一匹配的.
        for abnormal_Link in abnormal_Links_list:  #取数据的过程
            data_list.append(abnormal_Link[2])
        Links_dic=instrument.change_list_to_dict(Links_list,data_list)#输入两个列表,将其一一匹配的保存为字典格式:{IP字符串:连接数,...}
        order_Links_Ranks = sorted(Links_dic.items(), key=lambda x: x[1], reverse=True)#按照连接数重新排序字典,排序保存为[(IP字符串,连接数)...]
        self.Rank(order_Links_Ranks,1)  #显示至下部列表框
        self.load_in_flag = 1           #导入完毕,标记置1
        # 生成异常IP详细字典,由于需要用到graph的相关指标，输入参数需要graphs对象和异常IP的列表,具体过程详见函数部分
        abnormal_IPs_detail_dict=instrument.create_abnormal_IPs_dict(self.graphs,abnormal_IPs_list)
        self.flag_for_section=4         #导入后默认为异常IP分析模块


    # 点列表框选中事件
    def show_msg(self,*args):
        #导入后才有效
        if self.load_in_flag == 1:
            string = str(self.ip_listbox.get(self.ip_listbox.curselection()[0])) #取列表框中的字符串,.curselection返回的是(索引,)
            IP = re.split(r"->| ", string)                                       #正则分割,得到分割后的列表
            self.IP_details(IP[0])                                               #取IP送进details函数显示选中IP的数据
            self.control_title.config(text=IP[0])                                #修改label,显示当前选中的IP


    #上部选择按钮调用函数
    def menu_select(self):
        #导入后才有效
        if self.load_in_flag == 1:
            global GUI_ID
            GUI_ID += 1        #确定后会打开新的窗口,因此增加全局GUI_ID
            string = str(self.ip_listbox.get(self.ip_listbox.curselection()[0]))
            string_part = string.split()
            # 以当前GUI的绝对梗作为新GUI的绝对根,以列表框选中的IP为核心IP.作为参数传递生成新的GUI.
            w1 = App(self.final_root,string_part[0])
            self.certain_button.wait_window(w1.root)    #w1开启内部循环-即运行


    #主GUI未定义,子GUI用于关闭
    def menu_return(self):
        if self.GUI_ID != 0:
            self.root.destroy()


    #上部单选框调用函数
    def radCall(self):
        radSelect = self.rad_1.get()     #获取单选框选中的索引
        # 判断是否处于异常IP模块
        if self.flag_for_section!=4:
            if self.flag_for_section == 2:    #如果是单点分析模块,为了防止图污染,事先会保存一份本地副本,这里为重新加载本地副本
                self.graphs.J = self.A.copy()
                self.graphs.L = self.B.copy()
            if radSelect == 0:
                self.control_tip.config(text="IP节点                                点的度")
                IPs_to_show=list(self.graphs.degree(self.flag_for_section))  #调用度排序(剩下的结构类似不再注释)
                self.Rank(IPs_to_show)
            elif radSelect == 1:
                self.control_tip.config(text="IP节点                                介数中心性")
                IPs_to_show = list(self.graphs.betweeness(self.flag_for_section))
                self.Rank(IPs_to_show)
            elif radSelect == 2:
                self.control_tip.config(text="IP节点                                点度中心性")
                IPs_to_show = list(self.graphs.degree_centrality(self.flag_for_section))#从nx里取到的三个指标都返回的是元组列表
                self.Rank(IPs_to_show)
            elif radSelect == 3:
                self.control_tip.config(text="IP节点                                连接数")
                IPs_to_show=self.graphs.transfer_nodes()    #单纯的返回IP列表,虽然同名但是和上三个的结构并不同
                self.Rank(Analyser.Node_Links_Analyse(IPs_to_show))  #Rank内的参数变为元组列表,转变过程详见Analyse的函数注释
            elif radSelect == 4:
                self.control_tip.config(text="IP节点                                小包占比")
                IPs_to_show = self.graphs.transfer_nodes()  #原理同上
                self.Rank(Analyser.Node_Length_Analyse(IPs_to_show))
            elif radSelect == 5:
                self.control_tip.config(text="IP节点                                怀疑度")
                IPs_to_show = self.graphs.transfer_nodes()  #取J图的节点-事实上在生成G图时,会复制一份给J,因此主GUI同样适用
                IPs_suspicious_degree = []                  #存所有IP的可疑度的列表:[(IP,可疑度)...]
                #构建tuple,添加至上述列表
                for IP in IPs_to_show:
                    if IP not in abnormal_IPs_list:
                        IP_suspicious_degree_tuple=(IP,0)   #如果IP不在异常IP列表,那可疑度一定为0
                    else:
                        #如果IP在异常IP列表,那异常IP详细字典中一定记录了其可疑度,读字典相应数据填写可疑度
                        IP_suspicious_degree_tuple = (IP, abnormal_IPs_detail_dict[IP]['suspicious_degree'])
                    IPs_suspicious_degree.append(IP_suspicious_degree_tuple)
                #根据可疑度排序,输出排序后的元组列表
                order_suspicious_rank = sorted(IPs_suspicious_degree, key=lambda x: x[1], reverse=True)
                self.Rank(order_suspicious_rank)     #显示数据
        #如果处于异常IP模块,利用异常IP详细字典直接对所有异常IP的数据按序排序即可,元组列表的生成详见instrument相关函数
        elif self.flag_for_section==4:
            if radSelect == 0:
                self.control_tip.config(text="IP节点                                点的度")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict,"degree"))
            elif radSelect == 1:
                self.control_tip.config(text="IP节点                                介数中心性")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict,"betweeness"))
            elif radSelect == 2:
                self.control_tip.config(text="IP节点                                点度中心性")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict,"centrality"))
            elif radSelect == 3:
                self.control_tip.config(text="IP节点                                连接数")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "link"))
            elif radSelect == 4:
                self.control_tip.config(text="IP节点                                小包占比")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "length_prop"))
            elif radSelect == 5:
                self.control_tip.config(text="IP节点                                怀疑度")
                self.Rank(instrument.change_abnormal_dict_to_tuplelist(abnormal_IPs_detail_dict, "suspicious_degree"))


    #边列表框选中事件
    def show_msg_2(self,*args):
        string = str(self.ip_listbox_2.get(self.ip_listbox_2.curselection()[0]))
        IP = re.split(r"->| ", string)
        self.Link_details(IP[0], IP[1])  #返回边信息
        self.control_title_2.config(text=IP[0]+"->"+IP[1])


    #暂用作实验按钮
    def menu_select_2(self):
        print(self.A.nodes)
        print("select")

    #暂未定义
    def menu_return_2(self):
        print("return")


    #暂未定义
    def radCall_Line(self):
        print("radCall")


    #填充列表框数据函数
    def Rank(self,Informs,type=0):
        '''
        #由于历史原因,函数名和实际作用并不同.这个函数不是用来排序的,而是用来将排序好的元组列表显示到列表框中的.
        # 参数type决定上下列表框,0为上,1为下.
        # 参数Informs传递元组列表[(IP,data)...]
        '''
        if type==0:
            self.ip_listbox.delete(0, 'end')
            for Inform in Informs:
                format_string = "%(IP)-40s%(Count) 8.2f" % {'IP': Inform[0], 'Count': Inform[1]} #生成格式化字符串
                self.ip_listbox.insert('end', format_string)   #在列表框末尾插入字符串
            self.ip_listbox.select_set(0)                      #列表框自动选中索引0
        elif type==1:
            self.ip_listbox_2.delete(0, 'end')
            for Inform in Informs:
                format_string = "%(IP)-40s%(Count) 8.2f" % {'IP': Inform[0], 'Count': Inform[1]}
                self.ip_listbox_2.insert('end', format_string)
            self.ip_listbox_2.select_set(0)


    #点数据分析函数-输入IP,显示该点的所有相关数据
    def IP_details(self,IP):
        mode=0#nx的相关指标在全图或连通图内才有意义,暂设为全图下的统计.该参数使IP对指标的分析不受当前显示的图的影响.总基于全图.
        IPs=self.graphs.degree(mode)#由于nx无法分析单个指定IP,因此先拉出所有点的相关信息,再从相应的元组列表中找到该IP及对应数据
        for IP_degree in IPs:
            if operator.eq(IP,IP_degree[0])==True: #字符串相等,似乎可以直接用'==',IP_degree是元组(IP,data),下同
                self.inform_Text0.config(text="度")
                self.inform_Text1.config(text=IP_degree[1])
                break
        IPs = self.graphs.betweeness(mode)
        for IP_betweeness in IPs:
            if operator.eq(IP,IP_betweeness[0])==True:
                self.inform_Text2.config(text="介数中心性")
                self.inform_Text3.config(text=round(IP_betweeness[1],5))
                break
        IPs = self.graphs.degree_centrality(mode)
        for IP_centrality in IPs:
            if operator.eq(IP, IP_centrality[0])==True:
                self.inform_Text4.config(text="点度中心性")
                self.inform_Text5.config(text=round(IP_centrality[1],5))
                break
        IP_list=[]   #由于Analyser的两个函数为了支持批量处理,输入IP都是以列表的方式,因此构造一个仅一项的列表,便于调用函数
        IP_list.append(IP)
        self.inform_Text6.config(text="连接数")
        self.inform_Text8.config(text="小包占比")
        self.inform_Text7.config(text=Analyser.Node_Links_Analyse(IP_list)[0][1])  #具体详见Analyser中的函数注释
        self.inform_Text9.config(text=round(Analyser.Node_Length_Analyse(IP_list)[0][1],5))#round函数控制小数点位数
        #异常属性判断
        if IP in abnormal_IPs_detail_dict.keys():#其实这里用abnormal_list来判断更简洁,因为dict的keys就是前者,懒得改了
            #分别取IP的各类异常状态
            self.inform_Text11.config(text=abnormal_IPs_detail_dict[IP]['dga'])
            self.inform_Text13.config(text=abnormal_IPs_detail_dict[IP]['flawedAmy'])
        else:
            #正常的IP一定没有异常属性
            self.inform_Text11.config(text="No")
            self.inform_Text13.config(text="Null")


    #边数据分析函数-输入IP对,显示该边的所有相关数据
    def Link_details(self,IP1,IP2):
        self.spe_inform_Text1.config(text=Analyser.Link_Connection(IP1,IP2))
        String=Analyser.Link_Length_Analyse(IP1,IP2)  #详见对应函数,返回得到String列表,分别为小包,大包占比
        self.spe_inform_Text3.config(text=String[0])
        self.spe_inform_Text5.config(text=String[1])
        String=Analyser.Link_Protocol_Analyse(IP1,IP2) #同上,返回各类协议占比,这里String列表长度不止2
        self.spe_inform_Text7.config(text=String[0])
        self.spe_inform_Text9.config(text=String[1])


    #调用主循环不解释
    def Mainloop(self):
        self.root.mainloop()


    #加载png图片需要的一系列调整,输入png图的名字,需要后缀
    def Load_img(self,name):
        self.img = Image.open(name)  # 打开图片
        w_box = 780    #我也不知道这干啥的,似乎是设置GUI的当前大小,因为这个函数的作用之一是根据GUI大小调整图片大小
        h_box = 900
        img_resized = self.resize(w_box, h_box, self.img)  # 缩放图像让它保持比例，同时限制在一个矩形框范围内  【调用函数，返回整改后的图片】
        self.photo = ImageTk.PhotoImage(img_resized)  # 用PIL模块的PhotoImage打开.因为tkinter无法直接打开png格式的图
        self.Label_Image.config(image=self.photo)     # 显示图片


    #调整图片大小的函数,网上参考的,具体我也不知道这是个啥
    def resize(self,w_box, h_box, pil_image):  # 参数是：要适应的窗口宽、高、Image.open后的图片
        w, h = pil_image.size  # 获取图像的原始大小
        f1 = 1.0 * w_box / w
        f2 = 1.0 * h_box / h
        factor = min([f1, f2])
        width = int(w * factor)
        height = int(1.5*h * factor)
        return pil_image.resize((width, height), Image.ANTIALIAS)


#由于异常IP详细字典是保存本文件下的,因此其他类或文件需要使用时需要通过此函数来读取
def read_abnormal_abnormal_IPs_detail_dict():
    return abnormal_IPs_detail_dict


#主函数入口
if __name__ == '__main__':
    app = App()
    app.Mainloop()

