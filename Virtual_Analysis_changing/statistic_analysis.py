# coding=UTF-8
import db_helper
import re
import math
import matplotlib.pyplot as plt


def statistic_analysis_entrance():
    print("statistic analysis start")
    packet_num_dict = get_packet_num()
    tcp_flow_num_dict = get_tcp_flow()
    duration = get_time_duration()

    all_packet_num = packet_num_dict["packets"]
    tcp_packet_num = packet_num_dict["tcp_packets"]
    udp_packet_num = packet_num_dict["udp_packets"]
    http_packet_num = packet_num_dict["http_packets"]
    https_packet_num = packet_num_dict["https_packets"]
    dns_packet_num = packet_num_dict["dns_packets"]

    average_len = int(get_average_num())

    ip_num_dict = get_ip_num_dict()
    ip_kind_num = ip_num_dict.keys().__len__()
    ip_connect_num_dict = get_ip_connect_dict()
    ip_connect_kind_num = ip_connect_num_dict.keys().__len__()
    tcp_flow_num = tcp_flow_num_dict.keys().__len__()

    pps = packet_per_second(duration, all_packet_num)
    tcp_proportion = get_proportion(all_packet_num, tcp_packet_num)
    udp_proportion = get_proportion(all_packet_num, udp_packet_num)
    dns_proportion = get_proportion(all_packet_num, dns_packet_num)
    http_proportion = get_proportion(all_packet_num, http_packet_num)
    https_proportion = get_proportion(all_packet_num, https_packet_num)

    length_distribution = get_length_distribution(all_packet_num)
    '''
    print(duration)
    print("-----------------------")
    print(all_packet_num)
    print(tcp_packet_num)
    print(udp_packet_num)
    print(http_packet_num)
    print(https_packet_num)
    print(dns_packet_num)
    print("-----------------------")
    print(average_len)
    print(ip_kind_num)
    print(ip_connect_kind_num)
    print(tcp_flow_num)
    print("-----------------------")
    print(pps)
    print(tcp_proportion)
    print(dns_proportion)
    print(http_proportion)
    print(https_proportion)
    print("-----------------------")
    print(length_distribution)
    '''
    protocol_proportions = [tcp_proportion, udp_proportion, dns_proportion, http_proportion, https_proportion]
    protocol_proportions_str = ""
    for protocol_proportion in protocol_proportions:
        protocol_proportions_str = protocol_proportions_str + str(protocol_proportion) + ","
    protocol_proportions_str = protocol_proportions_str[0:len(protocol_proportions_str) - 1]
    length_distribution_str = ""
    for length in length_distribution:
        length_distribution_str = length_distribution_str + str(length) + ","
    length_distribution_str = length_distribution_str[0:len(length_distribution_str) - 1]
    feature_tuple = (0, duration, all_packet_num, average_len, ip_kind_num, ip_connect_kind_num, tcp_flow_num, str(pps),
                     protocol_proportions_str, length_distribution_str)
    feature_tuple_list = []
    feature_tuple_list.append(feature_tuple)
    save_net_statistic_feature(feature_tuple_list)
    feature_score(5, protocol_proportions + length_distribution)
    out_put_datas = [duration, all_packet_num, tcp_packet_num, udp_packet_num, http_packet_num, https_packet_num,
                     dns_packet_num, average_len, ip_kind_num, ip_connect_kind_num, tcp_flow_num, pps,
                     protocol_proportions, length_distribution]
    return out_put_datas


def get_time_duration():
    sql = "select Second from basic_part_data limit 1"
    start_time = db_helper.get_data(sql)[0][0]
    sql = "select Second from basic_part_data order by Second desc limit 1"
    end_time = db_helper.get_data(sql)[0][0]
    duration = end_time - start_time
    if duration == 0:
        duration = 1
    return duration


def get_average_num():
    sql = "select AVG(Len) from basic_part_data"
    average_len = db_helper.get_data(sql)[0][0]
    return average_len


def get_ip_num_dict():
    ip_num_dict = {}
    sql = "Select Distinct Src_IP, Count(*) From basic_part_data Group by Src_IP"
    results = db_helper.get_data(sql)
    results = list(results)
    for result in results:
        ip_num_dict[result[0]] = result[1]
    sql = "Select Distinct Dst_IP, Count(*) From basic_part_data Group by Dst_IP"
    results = db_helper.get_data(sql)
    results = list(results)
    dict_keys = ip_num_dict.keys()
    for result in results:
        if result[0] in dict_keys:
            ip_num_dict[result[0]] = ip_num_dict.get(result[0]) + result[1]
        else:
            ip_num_dict[result[0]] = result[1]
    return ip_num_dict


def get_ip_connect_dict():
    sql = "Select Distinct Src_IP,Dst_IP, Count(*) From basic_part_data Group by Src_IP,Dst_IP"
    ip_connect_dict = {}
    results = db_helper.get_data(sql)
    results = list(results)
    for result in results:
        connection_pair = (result[0],result[1])
        ip_connect_dict[connection_pair] = result[2]
    return ip_connect_dict


def get_packet_num():
    db_names = ["basic_part_data", "tcp_part_data", "udp_part_data", "http_part_data", "https_part_data",
                "dns_part_data"]
    strs = ["packets", "tcp_packets", "udp_packets", "http_packets", "https_packets", "dns_packets"]
    i = 0
    packet_nums = {}
    for db_name in db_names:
        sql = "SELECT COUNT(*) FROM " + db_name
        result = db_helper.get_data(sql)[0][0]
        packet_nums[strs[i]] = result
        i += 1
    return packet_nums


def packet_per_second(second, packets):
    return round(packets/second,3)


def get_tcp_flow():
    sql = "SELECT DISTINCT Src_IP,Dst_IP,Src_port,Dst_port,Protocol,COUNT(*)FROM basic_part_data basic, " \
          "tcp_part_data tcp  where  basic.Id = tcp.Id Group by Src_IP,Dst_IP,Src_port,Dst_port,Protocol"
    results = db_helper.get_data(sql)
    results = list(results)
    tcp_flow_dict = {}
    for result in results:
        exist_keys = tcp_flow_dict.keys()
        temp_key = (result[0], result[1], result[2], result[3], result[4])
        symmetrical_temp_key = (result[1], result[0], result[3], result[2], result[4])
        if temp_key in exist_keys:
            tcp_flow_dict[temp_key] = tcp_flow_dict[temp_key] + result[5]
        elif symmetrical_temp_key in exist_keys:
            tcp_flow_dict[symmetrical_temp_key] = tcp_flow_dict[symmetrical_temp_key] + result[5]
        else:
            tcp_flow_dict[temp_key] = result[5]
    return tcp_flow_dict


def get_proportion(total, sub):
    return round(sub/total * 100, 2)


def get_length_distribution(total):
    min = 0
    max = 200
    distribution_list = []
    while max < 1601:
        sql = "Select COUNT(*) FROM basic_part_data where Len> " + str(min) + " and Len < " + str(max)
        result = db_helper.get_data(sql)[0][0]
        result = round(result/total * 100, 2)
        distribution_list.append(result)
        min += 200
        max += 200
    return distribution_list


def save_net_statistic_feature(input_list):
    sql = "INSERT INTO net_statistic_feature(Id,Duration,All_packet_num,Average_len,Ip_kind_num," \
          "Ip_connection_kind_num,Tcp_flow_num,Pps,Protocol_proportion,Length_distribution)" \
          "VALUES(%d,%d,%d,%d,%d,%d,%d,%s,%s,%s)"
    db_helper.insert_batch(sql, input_list)


def feature_score(id, now_data_list):
    sql = "Select Protocol_proportion,Length_distribution From net_statistic_feature where Id = " + str(id)
    print(sql)
    results = db_helper.get_data(sql)
    #print(results)
    temp_list = list(results[0])
    #print(temp_list)
    datas = []
    for string in temp_list:
        datas += re.split(r",|",string)
    #print(datas)
    squre = 0
    for i in range(0, 13):
        squre += pow(now_data_list[i] - float(datas[i]), 2)
    score = math.sqrt(squre)
    print(score)


def draw_pie(propers, labels, title):
    plt.figure(figsize=(6, 5))
    colors = ['red', 'yellow', 'blue', 'green', 'pink', 'orange', 'olive', 'cyan', 'purple']
    act_labels = []
    act_propers = []
    act_colors = []
    explode = []
    counter = 0
    for proper in propers:
        proper_float = float(proper)
        if proper_float != 0:
            act_labels.append(labels[counter])
            act_propers.append(proper_float)
            act_colors.append(colors[counter])
            explode.append(0.05)
        counter += 1
    act_explode = tuple(explode)

    patches, l_text, p_text = plt.pie(act_propers, explode=act_explode, labels= act_labels, colors=act_colors,
                                       labeldistance=1.2, autopct='%2.1f%%', shadow=True,
                                       startangle=90, pctdistance=0.8)

    # labeldistance，文本的位置离远点有多远，1.1指1.1倍半径的位置
    # autopct，圆里面的文本格式，%3.1f%%表示小数有三位，整数有一位的浮点数
    # shadow，饼是否有阴影
    # startangle，起始角度，0，表示从0开始逆时针转，为第一块。一般选择从90度开始比较好看
    # pctdistance，百分比的text离圆心的距离
    # patches, l_texts, p_texts，为了得到饼图的返回值，p_texts饼图内部文本的，l_texts饼图外label的文本

    # 改变文本的大小
    # 方法是把每一个text遍历。调用set_size方法设置它的属性
    for t in l_text:
        t.set_size = 30
    for t in p_text:
        t.set_size = 20
        # 设置x，y轴刻度一致，这样饼图才能是圆的
    plt.axis('equal')
    plt.legend(loc='upper left', bbox_to_anchor=(-0.1, 1.1))
    # loc: 表示legend的位置，包括'upper right','upper left','lower right','lower left'等
    # bbox_to_anchor: 表示legend距离图形之间的距离，当出现图形与legend重叠时，可使用bbox_to_anchor进行调整legend的位置
    # 由两个参数决定，第一个参数为legend距离左边的距离，第二个参数为距离下面的距离
    plt.grid()
    plt.savefig(title + "_pie.png")
    plt.clf()
    plt.close('all')


def draw_bar(numbers, labels,title):
    colors = ['red', 'yellow', 'blue', 'green', 'pink', 'orange', 'olive', 'cyan', 'purple']
    rects = plt.bar(range(len(labels)), numbers, color=colors)
    max_values = max(numbers)
    # X轴标题
    index = [x for x in range(len(labels))]
    index = [float(c) + 0.4 for c in index]
    plt.ylim(ymax=max_values, ymin=0)
    plt.xticks(index, labels)
    plt.ylabel("packet number")  # X轴标签
    for rect in rects:
        height = rect.get_height()
        plt.text(rect.get_x() + rect.get_width() / 2, height, str(height), ha='center', va='bottom')
    plt.savefig(title + "_bar.png")
    plt.clf()
    plt.close('all')


if __name__ == '__main__':
     statistic_analysis_entrance()