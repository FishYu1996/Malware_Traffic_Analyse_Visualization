
from __future__ import print_function
from numpy import *
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense, Embedding
from keras.layers import LSTM
from keras.datasets import imdb
from sklearn.model_selection import train_test_split
from keras.layers import *
from keras.models import load_model
import collections

dict = collections.OrderedDict(
    [("0", 0), ("1", 1), ("2", 2), ("3", 3), ("4", 4), ("5", 5), ("6", 6), ("7", 7), ("8", 8),
     ("9", 9), ("a", 10), ("b", 11), ("c", 12), ("d", 13), ("e", 14), ("f", 15), ("g", 16), ("h", 17), ("i", 18),
     ("j", 19), ("k", 20), ("l", 21), ("m", 22), ("n", 23), ("o", 24), ("p", 25), ("q", 26), ("r", 27), ("s", 28),
     ("t", 29), ("u", 30), ("v", 31), ("w", 32), ("x", 33), ("y", 34), ("z", 35), ("-", 36), ("_", 37)])
#必须是有序字典，否则每次运行程序，valuelist都不相同，导入模型后几乎没有准确率，使用有序字典后保证每次valuelist都是一致的

def text_to_list(inputlists):
    changed_list = []
    keylist = list(dict.keys())
    # 把每行字符变成数字列表
    for input in inputlists:
        code = []
        for char in input:
            if char in keylist:
                index = keylist.index(char)
                code.append(index)
        changed_list.append(code)
    return changed_list


def list_to_text(input):
    str = ''
    char=[]
    for int in input:
        char.append(list(dict.keys())[list(dict.values()).index(int)])
    str=str.join(char)
    return str


def predict_dga(inputlists):
    input_list=text_to_list(inputlists)
    abnormal_domain=[]
    '''
list = text_to_list('shortdomain.txt')
print('dga域名的个数',len(list))
list1 = text_to_list('true_domain1.txt')
dga_number = len(list)
print('真实域名的个数：',len(list1))
# 把真实域名加入到训练列表中
for j in range(len(list1)):
    list.append(list1[j])
length = len(list)
#print(list)
# 扩充为7维向量
for i in range(length):
    a =list[i]
    if len(a)<7:
        for k in range(7-len(a)):
            a.append(0)
#print('域名列表:', len(list), list)
# 构建标签列表,dga域名标签为0，真实域名标签为1
y_list = []
for i in range(dga_number):
    y_list.append(0)
for j in range(len(list1)):
    y_list.append(1)
print('域名列表长度：',len(list),'标签列表长度：',len(y_list))

print('标签列表：', len(y_list), y_list)
X_train,X_test, y_train, y_test = train_test_split(list, y_list,test_size=0.2, random_state=0)
print('训练列表', len(X_train), X_train)
print('测试列表', len(X_test), X_test)
print('训练标签', len(y_train), y_train)
print('测试标签', len(y_test), y_test)

max_features = 40
maxlen = 20  # cut texts after this number of words (among top max_features most common words)
batch_size = 32

print(len(X_train), 'train sequences')
print(len(X_test), 'test sequences')

print('Pad sequences (samples x time)')
x_train = sequence.pad_sequences(X_train, maxlen=maxlen)
x_test = sequence.pad_sequences(X_test, maxlen=maxlen)
print('x_train shape:', x_train.shape)
print('x_test shape:', x_test.shape)


print('Build model...')

model = Sequential()
model.add(Embedding(max_features, 128))
model.add(LSTM(128, dropout=0.01, recurrent_dropout=0.01, kernel_regularizer=regularizers.l1(0.001)))
model.add(Dense(1, activation='sigmoid'))



#model = Sequential()
#model.add(Embedding(max_features, 128))
#model.add(LSTM(128))
## model.add(GRU(128))
#model.add(Dropout(0.5))
#model.add(Dense(1))
#model.add(Activation('sigmoid'))

# try using different optimizers and different optimizer configs
model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

print('Train...')
model.fit(x_train, y_train,
          batch_size=batch_size,
          epochs=5,
          validation_data=(x_test, y_test))
score, acc = model.evaluate(x_test, y_test,
                            batch_size=batch_size)
print('Test score:', score)
print('Test accuracy:', acc)

model.save('test_model.h5')

#del model
'''
    print("***********predicting***************")
    model=load_model('test_model.h5')
    x_test = sequence.pad_sequences(input_list, maxlen=20)
    predict = model.predict_classes(x_test, batch_size=100)
    predict_pro = model.predict(x_test, batch_size=100)
    for i in range(len(x_test)):
        print("X=%s, Predicted=%s,Pro=%s" % (x_test[i], predict[i], predict_pro[i]))
        if predict[i]==0:
            domain=list_to_text(input_list[i])
            abnormal_domain.append(domain)
        elif predict_pro[i]<=0.7:
            domain=list_to_text(input_list[i])
            abnormal_domain.append(domain)
    return abnormal_domain
